/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/schema-inspector";
exports.ids = ["vendor-chunks/schema-inspector"];
exports.modules = {

/***/ "(ssr)/./node_modules/schema-inspector/index.js":
/*!************************************************!*\
  !*** ./node_modules/schema-inspector/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/schema-inspector */ \"(ssr)/./node_modules/schema-inspector/lib/schema-inspector.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2NoZW1hLWluc3BlY3Rvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtSUFBa0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92b2ljZS1zdGFibGVzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3NjaGVtYS1pbnNwZWN0b3IvaW5kZXguanM/ZjBkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3NjaGVtYS1pbnNwZWN0b3InKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/schema-inspector/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/schema-inspector/lib/schema-inspector.js":
/*!***************************************************************!*\
  !*** ./node_modules/schema-inspector/lib/schema-inspector.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Disable no-var because we need to support old IE for now.\n/* eslint-disable no-var */\n// Disable space-before-function-paren for compatibility with VS Code default JS formatter.\n/* eslint-disable space-before-function-paren */\n\n/*\n * This module is intended to be executed both on client side and server side.\n * No error should be thrown. (soft error handling)\n */\n\n(function () {\n  var root = {};\n  // Dependencies --------------------------------------------------------------\n  root.async = ( true) ? __webpack_require__(/*! async */ \"(ssr)/./node_modules/async/dist/async.js\") : 0;\n  if (typeof root.async !== 'object') {\n    throw new Error('Module async is required (https://github.com/caolan/async)');\n  }\n  var async = root.async;\n\n  function _extend(origin, add) {\n    if (!add || typeof add !== 'object') {\n      return origin;\n    }\n    var keys = Object.keys(add);\n    var i = keys.length;\n    while (i--) {\n      origin[keys[i]] = add[keys[i]];\n    }\n    return origin;\n  }\n\n  function _merge() {\n    var ret = {};\n    var args = Array.prototype.slice.call(arguments);\n    var keys = null;\n    var i = null;\n\n    args.forEach(function (arg) {\n      if (arg && arg.constructor === Object) {\n        keys = Object.keys(arg);\n        i = keys.length;\n        while (i--) {\n          ret[keys[i]] = arg[keys[i]];\n        }\n      }\n    });\n    return ret;\n  }\n\n  // Customisable class (Base class) -------------------------------------------\n  // Use with operation \"new\" to extend Validation and Sanitization themselves,\n  // not their prototype. In other words, constructor shall be call to extend\n  // those functions, instead of being in their constructor, like this:\n  //   _extend(Validation, new Customisable);\n\n  function Customisable() {\n    this.custom = {};\n\n    this.extend = function (custom) {\n      return _extend(this.custom, custom);\n    };\n\n    this.reset = function () {\n      this.custom = {};\n    };\n\n    this.remove = function (fields) {\n      if (!_typeIs.array(fields)) {\n        fields = [fields];\n      }\n      fields.forEach(function (field) {\n        delete this.custom[field];\n      }, this);\n    };\n  }\n\n  // Inspection class (Base class) ---------------------------------------------\n  // Use to extend Validation and Sanitization prototypes. Inspection\n  // constructor shall be called in derived class constructor.\n\n  function Inspection(schema, custom) {\n    var _stack = ['@'];\n\n    this._schema = schema;\n    this._custom = {};\n    if (custom != null) {\n      for (var key in custom) {\n        if (Object.prototype.hasOwnProperty.call(custom, key)) {\n          this._custom['$' + key] = custom[key];\n        }\n      }\n    }\n\n    this._getDepth = function () {\n      return _stack.length;\n    };\n\n    this._dumpStack = function () {\n      /* eslint-disable no-control-regex */\n      return _stack.map(function (i) { return i.replace(/^\\[/g, '\\u001b\\u001c\\u001d\\u001e'); })\n        .join('.').replace(/\\.\\u001b\\u001c\\u001d\\u001e/g, '[');\n      /* eslint-enable no-control-regex */\n    };\n\n    this._deeperObject = function (name) {\n      _stack.push((/^[a-z$_][a-z0-9$_]*$/i).test(name) ? name : '[\"' + name + '\"]');\n      return this;\n    };\n\n    this._deeperArray = function (i) {\n      _stack.push('[' + i + ']');\n      return this;\n    };\n\n    this._back = function () {\n      _stack.pop();\n      return this;\n    };\n  }\n  // Simple types --------------------------------------------------------------\n  // If the property is not defined or is not in this list:\n  var _typeIs = {\n    function: function (element) {\n      return typeof element === 'function';\n    },\n    string: function (element) {\n      return typeof element === 'string';\n    },\n    number: function (element) {\n      return typeof element === 'number' && !isNaN(element);\n    },\n    integer: function (element) {\n      return typeof element === 'number' && element % 1 === 0;\n    },\n    NaN: function (element) {\n      return typeof element === 'number' && isNaN(element);\n    },\n    boolean: function (element) {\n      return typeof element === 'boolean';\n    },\n    null: function (element) {\n      return element === null;\n    },\n    date: function (element) {\n      return element != null && element instanceof Date;\n    },\n    object: function (element) {\n      return typeof element === 'object' && element != null && element.constructor !== Array;\n    },\n    array: function (element) {\n      return element != null && element.constructor === Array;\n    },\n    any: function () {\n      return true;\n    }\n  };\n\n  function _simpleType(type, candidate) {\n    if (typeof type === 'function') {\n      return candidate instanceof type;\n    }\n    type = type in _typeIs ? type : 'any';\n    return _typeIs[type](candidate);\n  }\n\n  function _realType(candidate) {\n    for (var i in _typeIs) {\n      if (_simpleType(i, candidate)) {\n        if (i !== 'any' && (i !== 'object' || candidate.constructor === Object)) { return i; }\n        return 'an instance of ' + candidate.constructor.name;\n      }\n    }\n  }\n\n  function getIndexes(a, value) {\n    var indexes = [];\n    var i = a.indexOf(value);\n\n    while (i !== -1) {\n      indexes.push(i);\n      i = a.indexOf(value, i + 1);\n    }\n    return indexes;\n  }\n\n  // Available formats ---------------------------------------------------------\n  /* eslint-disable no-useless-escape */\n  // TODO: Study these regex expressions and add more tests so we can consider removing\n  // rule no-useless-escape.\n  var _formats = {\n    void: /^$/,\n    url: /^(https?|ftp):\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)?(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i,\n    'date-time': /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{3})?(Z?|(-|\\+)\\d{2}:\\d{2})$/,\n    date: /^\\d{4}-\\d{2}-\\d{2}$/,\n    coolDateTime: /^\\d{4}(-|\\/)\\d{2}(-|\\/)\\d{2}(T| )\\d{2}:\\d{2}:\\d{2}(\\.\\d{3})?Z?$/,\n    time: /^\\d{2}\\:\\d{2}\\:\\d{2}$/,\n    color: /^#([0-9a-f])+$/i,\n    // Very flexible regular expression designed to catch only obvious mistakes\n    // that a user might make that would have a 100% chance of causing email\n    // delivery to the address to fail. The library takes a flexible over\n    // strict approach. Users should use this only for basic front end email\n    // address validation and perform more strict checking using server-side\n    // code after the data has been sent to their server.\n    // Sourced from https://www.regular-expressions.info/email.html, modified\n    // to allow lowercase characters too.\n    email: /^[^@]+@[^.]+\\.[a-zA-Z]+$/,\n    /* eslint-enable prefer-regex-literals */\n    /* eslint-enable quotes */\n    numeric: /^[0-9]+$/,\n    integer: /^\\-?[0-9]+$/,\n    decimal: /^\\-?[0-9]*\\.?[0-9]+$/,\n    alpha: /^[a-z]+$/i,\n    alphaNumeric: /^[a-z0-9]+$/i,\n    alphaDash: /^[a-z0-9_-]+$/i,\n    javascript: /^[a-z_\\$][a-z0-9_\\$]*$/i,\n    upperString: /^[A-Z ]*$/,\n    lowerString: /^[a-z ]*$/,\n    v4uuid: /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$/i\n  };\n  /* eslint-enable no-useless-escape */\n\n  // Validation ------------------------------------------------------------------\n  var _validationAttribut = {\n    optional: function (schema, candidate) {\n      var opt = typeof schema.optional === 'boolean' ? schema.optional : (schema.optional === 'true'); // Default is false\n\n      if (opt === true) {\n        return;\n      }\n      if (typeof candidate === 'undefined') {\n        this.report('is missing and not optional', null, 'optional');\n      }\n    },\n    type: function (schema, candidate) {\n      // return because optional function already handle this case\n      if (typeof candidate === 'undefined' || (typeof schema.type !== 'string' && !(schema.type instanceof Array) && typeof schema.type !== 'function')) {\n        return;\n      }\n      var types = _typeIs.array(schema.type) ? schema.type : [schema.type];\n      var typeIsValid = types.some(function (type) {\n        return _simpleType(type, candidate);\n      });\n      if (!typeIsValid) {\n        types = types.map(function (t) { return typeof t === 'function' ? 'an instance of ' + t.name : t; });\n        this.report('must be ' + types.join(' or ') + ', but is ' + _realType(candidate), null, 'type');\n      }\n    },\n    uniqueness: function (schema, candidate) {\n      if (typeof schema.uniqueness === 'string') { schema.uniqueness = (schema.uniqueness === 'true'); }\n      if (typeof schema.uniqueness !== 'boolean' || schema.uniqueness === false || (!_typeIs.array(candidate) && typeof candidate !== 'string')) {\n        return;\n      }\n      var reported = [];\n      for (var i = 0; i < candidate.length; i++) {\n        if (reported.indexOf(candidate[i]) >= 0) {\n          continue;\n        }\n        var indexes = getIndexes(candidate, candidate[i]);\n        if (indexes.length > 1) {\n          reported.push(candidate[i]);\n          this.report('has value [' + candidate[i] + '] more than once at indexes [' + indexes.join(', ') + ']', null, 'uniqueness');\n        }\n      }\n    },\n    pattern: function (schema, candidate) {\n      var self = this;\n      var regexs = schema.pattern;\n      if (typeof candidate !== 'string') {\n        return;\n      }\n      var matches = false;\n      if (!_typeIs.array(regexs)) {\n        regexs = [regexs];\n      }\n      regexs.forEach(function (regex) {\n        if (typeof regex === 'string' && regex in _formats) {\n          regex = _formats[regex];\n        }\n        if (regex instanceof RegExp) {\n          if (regex.test(candidate)) {\n            matches = true;\n          }\n        }\n      });\n      if (!matches) {\n        self.report('must match [' + regexs.join(' or ') + '], but is equal to \"' + candidate + '\"', null, 'pattern');\n      }\n    },\n    validDate: function (schema, candidate) {\n      if (String(schema.validDate) === 'true' && candidate instanceof Date && isNaN(candidate.getTime())) {\n        this.report('must be a valid date', null, 'validDate');\n      }\n    },\n    minLength: function (schema, candidate) {\n      if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {\n        return;\n      }\n      var minLength = Number(schema.minLength);\n      if (isNaN(minLength)) {\n        return;\n      }\n      if (candidate.length < minLength) {\n        this.report('must be longer than ' + minLength + ' elements, but it has ' + candidate.length, null, 'minLength');\n      }\n    },\n    maxLength: function (schema, candidate) {\n      if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {\n        return;\n      }\n      var maxLength = Number(schema.maxLength);\n      if (isNaN(maxLength)) {\n        return;\n      }\n      if (candidate.length > maxLength) {\n        this.report('must be shorter than ' + maxLength + ' elements, but it has ' + candidate.length, null, 'maxLength');\n      }\n    },\n    exactLength: function (schema, candidate) {\n      if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {\n        return;\n      }\n      var exactLength = Number(schema.exactLength);\n      if (isNaN(exactLength)) {\n        return;\n      }\n      if (candidate.length !== exactLength) {\n        this.report('must have exactly ' + exactLength + ' elements, but it have ' + candidate.length, null, 'exactLength');\n      }\n    },\n    lt: function (schema, candidate) {\n      var limit = Number(schema.lt);\n      if (typeof candidate !== 'number' || isNaN(limit)) {\n        return;\n      }\n      if (candidate >= limit) {\n        this.report('must be less than ' + limit + ', but is equal to \"' + candidate + '\"', null, 'lt');\n      }\n    },\n    lte: function (schema, candidate) {\n      var limit = Number(schema.lte);\n      if (typeof candidate !== 'number' || isNaN(limit)) {\n        return;\n      }\n      if (candidate > limit) {\n        this.report('must be less than or equal to ' + limit + ', but is equal to \"' + candidate + '\"', null, 'lte');\n      }\n    },\n    gt: function (schema, candidate) {\n      var limit = Number(schema.gt);\n      if (typeof candidate !== 'number' || isNaN(limit)) {\n        return;\n      }\n      if (candidate <= limit) {\n        this.report('must be greater than ' + limit + ', but is equal to \"' + candidate + '\"', null, 'gt');\n      }\n    },\n    gte: function (schema, candidate) {\n      var limit = Number(schema.gte);\n      if (typeof candidate !== 'number' || isNaN(limit)) {\n        return;\n      }\n      if (candidate < limit) {\n        this.report('must be greater than or equal to ' + limit + ', but is equal to \"' + candidate + '\"', null, 'gte');\n      }\n    },\n    eq: function (schema, candidate) {\n      if (typeof candidate !== 'number' && typeof candidate !== 'string' && typeof candidate !== 'boolean') {\n        return;\n      }\n      var limit = schema.eq;\n      if (typeof limit !== 'number' && typeof limit !== 'string' && typeof limit !== 'boolean' && !_typeIs.array(limit)) {\n        return;\n      }\n      if (_typeIs.array(limit)) {\n        for (var i = 0; i < limit.length; i++) {\n          if (candidate === limit[i]) {\n            return;\n          }\n        }\n        this.report('must be equal to [' + limit.map(function (l) {\n          return '\"' + l + '\"';\n        }).join(' or ') + '], but is equal to \"' + candidate + '\"', null, 'eq');\n      } else {\n        if (candidate !== limit) {\n          this.report('must be equal to \"' + limit + '\", but is equal to \"' + candidate + '\"', null, 'eq');\n        }\n      }\n    },\n    ne: function (schema, candidate) {\n      if (typeof candidate !== 'number' && typeof candidate !== 'string') {\n        return;\n      }\n      var limit = schema.ne;\n      if (typeof limit !== 'number' && typeof limit !== 'string' && !_typeIs.array(limit)) {\n        return;\n      }\n      if (_typeIs.array(limit)) {\n        for (var i = 0; i < limit.length; i++) {\n          if (candidate === limit[i]) {\n            this.report('must not be equal to \"' + limit[i] + '\"', null, 'ne');\n            return;\n          }\n        }\n      } else {\n        if (candidate === limit) {\n          this.report('must not be equal to \"' + limit + '\"', null, 'ne');\n        }\n      }\n    },\n    multipleOf: function (schema, candidate) {\n      const divisor = Number(schema.multipleOf);\n      if (typeof candidate !== 'number' || isNaN(divisor)) {\n        return;\n      }\n      if (candidate % divisor !== 0) {\n        this.report(candidate + ' is not divisible by ' + divisor, null, 'multipleOf');\n      }\n    },\n    someKeys: function (schema, candidat) {\n      var _keys = schema.someKeys;\n      if (!_typeIs.object(candidat)) {\n        return;\n      }\n      var valid = _keys.some(function (action) {\n        return (action in candidat);\n      });\n      if (!valid) {\n        this.report('must have at least key ' + _keys.map(function (i) {\n          return '\"' + i + '\"';\n        }).join(' or '), null, 'someKeys');\n      }\n    },\n    strict: function (schema, candidate) {\n      if (typeof schema.strict === 'string') { schema.strict = (schema.strict === 'true'); }\n      if (schema.strict !== true || !_typeIs.object(candidate) || !_typeIs.object(schema.properties)) {\n        return;\n      }\n      var self = this;\n      if (typeof schema.properties['*'] === 'undefined') {\n        var intruder = Object.keys(candidate).filter(function (key) {\n          return (typeof schema.properties[key] === 'undefined');\n        });\n        if (intruder.length > 0) {\n          var msg = 'should not contains ' + (intruder.length > 1 ? 'properties' : 'property') +\n            ' [' + intruder.map(function (i) { return '\"' + i + '\"'; }).join(', ') + ']';\n          self.report(msg, null, 'strict');\n        }\n      }\n    },\n    exec: function (schema, candidate, callback) {\n      var self = this;\n\n      if (typeof callback === 'function') {\n        return this.asyncExec(schema, candidate, callback);\n      }\n      (_typeIs.array(schema.exec) ? schema.exec : [schema.exec]).forEach(function (exec) {\n        if (typeof exec === 'function') {\n          exec.call(self, schema, candidate);\n        }\n      });\n    },\n    properties: function (schema, candidate, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncProperties(schema, candidate, callback);\n      }\n      if (!(schema.properties instanceof Object) || !(candidate instanceof Object)) {\n        return;\n      }\n      var properties = schema.properties;\n      var i;\n      if (properties['*'] != null) {\n        for (i in candidate) {\n          if (i in properties) {\n            continue;\n          }\n          this._deeperObject(i);\n          this._validate(properties['*'], candidate[i]);\n          this._back();\n        }\n      }\n      for (i in properties) {\n        if (i === '*') {\n          continue;\n        }\n        this._deeperObject(i);\n        this._validate(properties[i], candidate[i]);\n        this._back();\n      }\n    },\n    items: function (schema, candidate, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncItems(schema, candidate, callback);\n      }\n      if (!(schema.items instanceof Object) || !(candidate instanceof Object)) {\n        return;\n      }\n      var items = schema.items;\n      var i, l;\n      // If provided schema is an array\n      // then call validate for each case\n      // else it is an Object\n      // then call validate for each key\n      if (_typeIs.array(items) && _typeIs.array(candidate)) {\n        for (i = 0, l = items.length; i < l; i++) {\n          this._deeperArray(i);\n          this._validate(items[i], candidate[i]);\n          this._back();\n        }\n      } else {\n        for (var key in candidate) {\n          if (Object.prototype.hasOwnProperty.call(candidate, key)) {\n            this._deeperArray(key);\n            this._validate(items, candidate[key]);\n            this._back();\n          }\n        }\n      }\n    }\n  };\n\n  var _asyncValidationAttribut = {\n    asyncExec: function (schema, candidate, callback) {\n      var self = this;\n      async.eachSeries(_typeIs.array(schema.exec) ? schema.exec : [schema.exec], function (exec, done) {\n        if (typeof exec === 'function') {\n          if (exec.length > 2) {\n            return exec.call(self, schema, candidate, done);\n          }\n          exec.call(self, schema, candidate);\n        }\n        async.nextTick(done);\n      }, callback);\n    },\n    asyncProperties: function (schema, candidate, callback) {\n      if (!(schema.properties instanceof Object) || !_typeIs.object(candidate)) {\n        return callback();\n      }\n      var self = this;\n      var properties = schema.properties;\n      async.series([\n        function (next) {\n          if (properties['*'] == null) {\n            return next();\n          }\n          async.eachSeries(Object.keys(candidate), function (i, done) {\n            if (i in properties) {\n              return async.nextTick(done);\n            }\n            self._deeperObject(i);\n            self._asyncValidate(properties['*'], candidate[i], function (err) {\n              self._back();\n              done(err);\n            });\n          }, next);\n        },\n        function (next) {\n          async.eachSeries(Object.keys(properties), function (i, done) {\n            if (i === '*') {\n              return async.nextTick(done);\n            }\n            self._deeperObject(i);\n            self._asyncValidate(properties[i], candidate[i], function (err) {\n              self._back();\n              done(err);\n            });\n          }, next);\n        }\n      ], callback);\n    },\n    asyncItems: function (schema, candidate, callback) {\n      if (!(schema.items instanceof Object) || !(candidate instanceof Object)) {\n        return callback();\n      }\n      var self = this;\n      var items = schema.items;\n\n      if (_typeIs.array(items) && _typeIs.array(candidate)) {\n        async.timesSeries(items.length, function (i, done) {\n          self._deeperArray(i);\n          self._asyncValidate(items[i], candidate[i], function (err, res) {\n            self._back();\n            done(err, res);\n          });\n          self._back();\n        }, callback);\n      } else {\n        async.eachSeries(Object.keys(candidate), function (key, done) {\n          self._deeperArray(key);\n          self._asyncValidate(items, candidate[key], function (err, res) {\n            self._back();\n            done(err, res);\n          });\n        }, callback);\n      }\n    }\n  };\n\n  // Validation Class ----------------------------------------------------------\n  // inherits from Inspection class (actually we just call Inspection\n  // constructor with the new context, because its prototype is empty\n  function Validation(schema, custom) {\n    Inspection.prototype.constructor.call(this, schema, _merge(Validation.custom, custom));\n    var _error = [];\n\n    this._basicFields = Object.keys(_validationAttribut);\n    this._customFields = Object.keys(this._custom);\n    this.origin = null;\n\n    this.report = function (message, code, reason) {\n      var newErr = {\n        code: code || this.userCode || null,\n        reason: reason || 'unknown',\n        message: this.userError || message || 'is invalid',\n        property: this.userAlias ? (this.userAlias + ' (' + this._dumpStack() + ')') : this._dumpStack()\n      };\n      _error.push(newErr);\n      return this;\n    };\n\n    this.result = function () {\n      return {\n        error: _error,\n        valid: _error.length === 0,\n        format: function () {\n          if (this.valid === true) {\n            return 'Candidate is valid';\n          }\n          return this.error.map(function (i) {\n            return 'Property ' + i.property + ': ' + i.message;\n          }).join('\\n');\n        }\n      };\n    };\n  }\n\n  _extend(Validation.prototype, _validationAttribut);\n  _extend(Validation.prototype, _asyncValidationAttribut);\n  _extend(Validation, new Customisable());\n\n  Validation.prototype.validate = function (candidate, callback) {\n    this.origin = candidate;\n    if (typeof callback === 'function') {\n      var self = this;\n      return async.nextTick(function () {\n        self._asyncValidate(self._schema, candidate, function (err) {\n          self.origin = null;\n          callback(err, self.result());\n        });\n      });\n    }\n    return this._validate(this._schema, candidate).result();\n  };\n\n  Validation.prototype._validate = function (schema, candidate, callback) {\n    this.userCode = schema.code || null;\n    this.userError = schema.error || null;\n    this.userAlias = schema.alias || null;\n    this._basicFields.forEach(function (i) {\n      if ((i in schema || i === 'optional') && typeof this[i] === 'function') {\n        this[i](schema, candidate);\n      }\n    }, this);\n    this._customFields.forEach(function (i) {\n      if (i in schema && typeof this._custom[i] === 'function') {\n        this._custom[i].call(this, schema, candidate);\n      }\n    }, this);\n    return this;\n  };\n\n  Validation.prototype._asyncValidate = function (schema, candidate, callback) {\n    var self = this;\n    this.userCode = schema.code || null;\n    this.userError = schema.error || null;\n    this.userAlias = schema.alias || null;\n\n    async.series([\n      function (next) {\n        async.eachSeries(Object.keys(_validationAttribut), function (i, done) {\n          async.nextTick(function () {\n            if ((i in schema || i === 'optional') && typeof self[i] === 'function') {\n              if (self[i].length > 2) {\n                return self[i](schema, candidate, done);\n              }\n              self[i](schema, candidate);\n            }\n            done();\n          });\n        }, next);\n      },\n      function (next) {\n        async.eachSeries(Object.keys(self._custom), function (i, done) {\n          async.nextTick(function () {\n            if (i in schema && typeof self._custom[i] === 'function') {\n              if (self._custom[i].length > 2) {\n                return self._custom[i].call(self, schema, candidate, done);\n              }\n              self._custom[i].call(self, schema, candidate);\n            }\n            done();\n          });\n        }, next);\n      }\n    ], callback);\n  };\n\n  // Sanitization ----------------------------------------------------------------\n  // functions called by _sanitization.type method.\n  var _forceType = {\n    number: function (post, schema) {\n      var n;\n      if (typeof post === 'number') {\n        return post;\n      } else if (post === '') {\n        if (typeof schema.def !== 'undefined') {\n          return schema.def;\n        }\n        return null;\n      } else if (typeof post === 'string') {\n        n = parseFloat(post.replace(/,/g, '.').replace(/ /g, ''));\n        if (typeof n === 'number') {\n          return n;\n        }\n      } else if (post instanceof Date) {\n        return +post;\n      }\n      return null;\n    },\n    integer: function (post, schema) {\n      var n;\n      if (typeof post === 'number' && post % 1 === 0) {\n        return post;\n      } else if (post === '') {\n        if (typeof schema.def !== 'undefined') {\n          return schema.def;\n        }\n        return null;\n      } else if (typeof post === 'string') {\n        n = parseInt(post.replace(/ /g, ''), 10);\n        if (typeof n === 'number') {\n          return n;\n        }\n      } else if (typeof post === 'number') {\n        return parseInt(post, 10);\n      } else if (typeof post === 'boolean') {\n        if (post) { return 1; }\n        return 0;\n      } else if (post instanceof Date) {\n        return +post;\n      }\n      return null;\n    },\n    string: function (post, schema) {\n      if (typeof post === 'boolean' || typeof post === 'number' || post instanceof Date) {\n        return post.toString();\n      } else if (_typeIs.array(post)) {\n        // If user authorize array and strings...\n        if (schema.items || schema.properties) {\n          return post;\n        }\n        return post.join(String(schema.joinWith || ','));\n      } else if (post instanceof Object) {\n        // If user authorize objects ans strings...\n        if (schema.items || schema.properties) {\n          return post;\n        }\n        return JSON.stringify(post);\n      } else if (typeof post === 'string' && post.length) {\n        return post;\n      }\n      return null;\n    },\n    date: function (post, schema) {\n      if (post instanceof Date) {\n        return post;\n      } else {\n        var d = new Date(post);\n        if (!isNaN(d.getTime())) { // if valid date\n          return d;\n        }\n      }\n      return null;\n    },\n    boolean: function (post, schema) {\n      if (typeof post === 'undefined') return null;\n      if (typeof post === 'string' && post.toLowerCase() === 'false') return false;\n      return !!post;\n    },\n    object: function (post, schema) {\n      if (typeof post !== 'string' || _typeIs.object(post)) {\n        return post;\n      }\n      try {\n        return JSON.parse(post);\n      } catch (e) {\n        return null;\n      }\n    },\n    array: function (post, schema) {\n      if (_typeIs.array(post)) {\n        return post;\n      }\n      if (typeof post === 'undefined') {\n        return null;\n      }\n      if (typeof post === 'string') {\n        if (post.substring(0, 1) === '[' && post.slice(-1) === ']') {\n          try {\n            return JSON.parse(post);\n          } catch (e) {\n            return null;\n          }\n        }\n        return post.split(String(schema.splitWith || ','));\n      }\n      if (!_typeIs.array(post)) {\n        return [post];\n      }\n      return null;\n    }\n  };\n\n  var _applyRules = {\n    upper: function (post) {\n      return post.toUpperCase();\n    },\n    lower: function (post) {\n      return post.toLowerCase();\n    },\n    title: function (post) {\n      // Fix by seb (replace \\w\\S* by \\S* => exemple : coucou Ã§a va)\n      return post.replace(/\\S*/g, function (txt) {\n        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n      });\n    },\n    capitalize: function (post) {\n      return post.charAt(0).toUpperCase() + post.substr(1).toLowerCase();\n    },\n    ucfirst: function (post) {\n      return post.charAt(0).toUpperCase() + post.substr(1);\n    },\n    trim: function (post) {\n      return post.trim();\n    }\n  };\n\n  // Every function return the future value of each property. Therefore you\n  // have to return post even if you do not change its value\n  var _sanitizationAttribut = {\n    strict: function (schema, post) {\n      if (typeof schema.strict === 'string') { schema.strict = (schema.strict === 'true'); }\n      if (schema.strict !== true) {\n        return post;\n      }\n      if (!_typeIs.object(schema.properties)) {\n        return post;\n      }\n      if (!_typeIs.object(post)) {\n        return post;\n      }\n      Object.keys(post).forEach(function (key) {\n        if (!(key in schema.properties)) {\n          delete post[key];\n        }\n      });\n      return post;\n    },\n    optional: function (schema, post) {\n      var opt = typeof schema.optional === 'boolean' ? schema.optional : (schema.optional !== 'false'); // Default: true\n      if (opt === true) {\n        return post;\n      }\n      if (typeof post !== 'undefined') {\n        return post;\n      }\n      this.report();\n      if (schema.def === Date) {\n        return new Date();\n      }\n      return schema.def;\n    },\n    type: function (schema, post) {\n      // if (_typeIs['object'](post) || _typeIs.array(post)) {\n      //   return post;\n      // }\n      if (typeof schema.type !== 'string' || typeof _forceType[schema.type] !== 'function') {\n        return post;\n      }\n      var n;\n      var opt = typeof schema.optional === 'boolean' ? schema.optional : true;\n      if (typeof _forceType[schema.type] === 'function') {\n        n = _forceType[schema.type](post, schema);\n        if ((n === null && !opt) || (!n && isNaN(n)) || (n === null && schema.type === 'string')) {\n          n = schema.def;\n        }\n      } else if (!opt) {\n        n = schema.def;\n      }\n      if ((n != null || (typeof schema.def !== 'undefined' && schema.def === n)) && n !== post) {\n        this.report();\n        return n;\n      }\n      return post;\n    },\n    rules: function (schema, post) {\n      var rules = schema.rules;\n      if (typeof post !== 'string' || (typeof rules !== 'string' && !_typeIs.array(rules))) {\n        return post;\n      }\n      var modified = false;\n      (_typeIs.array(rules) ? rules : [rules]).forEach(function (rule) {\n        if (typeof _applyRules[rule] === 'function') {\n          post = _applyRules[rule](post);\n          modified = true;\n        }\n      });\n      if (modified) {\n        this.report();\n      }\n      return post;\n    },\n    min: function (schema, post) {\n      var postTest = Number(post);\n      if (isNaN(postTest)) {\n        return post;\n      }\n      var min = Number(schema.min);\n      if (isNaN(min)) {\n        return post;\n      }\n      if (postTest < min) {\n        this.report();\n        return min;\n      }\n      return post;\n    },\n    max: function (schema, post) {\n      var postTest = Number(post);\n      if (isNaN(postTest)) {\n        return post;\n      }\n      var max = Number(schema.max);\n      if (isNaN(max)) {\n        return post;\n      }\n      if (postTest > max) {\n        this.report();\n        return max;\n      }\n      return post;\n    },\n    minLength: function (schema, post) {\n      var limit = Number(schema.minLength);\n      if (typeof post !== 'string' || isNaN(limit) || limit < 0) {\n        return post;\n      }\n      var str = '';\n      var gap = limit - post.length;\n      if (gap > 0) {\n        for (var i = 0; i < gap; i++) {\n          str += '-';\n        }\n        this.report();\n        return post + str;\n      }\n      return post;\n    },\n    maxLength: function (schema, post) {\n      var limit = Number(schema.maxLength);\n      if (typeof post !== 'string' || isNaN(limit) || limit < 0) {\n        return post;\n      }\n      if (post.length > limit) {\n        this.report();\n        return post.slice(0, limit);\n      }\n      return post;\n    },\n    properties: function (schema, post, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncProperties(schema, post, callback);\n      }\n      if (!post || typeof post !== 'object') {\n        return post;\n      }\n      var properties = schema.properties;\n      var tmp;\n      var i;\n      if (typeof properties['*'] !== 'undefined') {\n        for (i in post) {\n          if (i in properties) {\n            continue;\n          }\n          this._deeperObject(i);\n          tmp = this._sanitize(properties['*'], post[i]);\n          if (typeof tmp !== 'undefined' || 'exec' in properties['*']) {\n            post[i] = tmp;\n          }\n          this._back();\n        }\n      }\n      for (i in properties) {\n        if (i !== '*') {\n          this._deeperObject(i);\n          tmp = this._sanitize(properties[i], post[i]);\n          if (typeof tmp !== 'undefined' || 'exec' in properties[i]) {\n            post[i] = tmp;\n          }\n          this._back();\n        }\n      }\n      return post;\n    },\n    items: function (schema, post, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncItems(schema, post, callback);\n      }\n      if (!(schema.items instanceof Object) || !(post instanceof Object)) {\n        return post;\n      }\n      var i;\n      if (_typeIs.array(schema.items) && _typeIs.array(post)) {\n        var minLength = schema.items.length < post.length ? schema.items.length : post.length;\n        for (i = 0; i < minLength; i++) {\n          this._deeperArray(i);\n          post[i] = this._sanitize(schema.items[i], post[i]);\n          this._back();\n        }\n      } else {\n        for (i in post) {\n          if (Object.prototype.hasOwnProperty.call(post, i)) {\n            this._deeperArray(i);\n            post[i] = this._sanitize(schema.items, post[i]);\n            this._back();\n          }\n        }\n      }\n      return post;\n    },\n    exec: function (schema, post, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncExec(schema, post, callback);\n      }\n      var execs = _typeIs.array(schema.exec) ? schema.exec : [schema.exec];\n\n      execs.forEach(function (exec) {\n        if (typeof exec === 'function') {\n          post = exec.call(this, schema, post);\n        }\n      }, this);\n      return post;\n    }\n  };\n\n  var _asyncSanitizationAttribut = {\n    asyncExec: function (schema, post, callback) {\n      var self = this;\n      var execs = _typeIs.array(schema.exec) ? schema.exec : [schema.exec];\n\n      async.eachSeries(execs, function (exec, done) {\n        if (typeof exec === 'function') {\n          if (exec.length > 2) {\n            return exec.call(self, schema, post, function (err, res) {\n              if (err) {\n                return done(err);\n              }\n              post = res;\n              done();\n            });\n          }\n          post = exec.call(self, schema, post);\n        }\n        done();\n      }, function (err) {\n        callback(err, post);\n      });\n    },\n    asyncProperties: function (schema, post, callback) {\n      if (!post || typeof post !== 'object') {\n        return callback(null, post);\n      }\n      var self = this;\n      var properties = schema.properties;\n\n      async.series([\n        function (next) {\n          if (properties['*'] == null) {\n            return next();\n          }\n          var globing = properties['*'];\n          async.eachSeries(Object.keys(post), function (i, next) {\n            if (i in properties) {\n              return next();\n            }\n            self._deeperObject(i);\n            self._asyncSanitize(globing, post[i], function (err, res) {\n              if (err) { /* Error can safely be ignored here */ }\n              if (typeof res !== 'undefined') {\n                post[i] = res;\n              }\n              self._back();\n              next();\n            });\n          }, next);\n        },\n        function (next) {\n          async.eachSeries(Object.keys(properties), function (i, next) {\n            if (i === '*') {\n              return next();\n            }\n            self._deeperObject(i);\n            self._asyncSanitize(properties[i], post[i], function (err, res) {\n              if (err) {\n                return next(err);\n              }\n              if (typeof res !== 'undefined') {\n                post[i] = res;\n              }\n              self._back();\n              next();\n            });\n          }, next);\n        }\n      ], function (err) {\n        return callback(err, post);\n      });\n    },\n    asyncItems: function (schema, post, callback) {\n      if (!(schema.items instanceof Object) || !(post instanceof Object)) {\n        return callback(null, post);\n      }\n      var self = this;\n      var items = schema.items;\n      if (_typeIs.array(items) && _typeIs.array(post)) {\n        var minLength = items.length < post.length ? items.length : post.length;\n        async.timesSeries(minLength, function (i, next) {\n          self._deeperArray(i);\n          self._asyncSanitize(items[i], post[i], function (err, res) {\n            if (err) {\n              return next(err);\n            }\n            post[i] = res;\n            self._back();\n            next();\n          });\n        }, function (err) {\n          callback(err, post);\n        });\n      } else {\n        async.eachSeries(Object.keys(post), function (key, next) {\n          self._deeperArray(key);\n          self._asyncSanitize(items, post[key], function (err, res) {\n            if (err) {\n              return next();\n            }\n            post[key] = res;\n            self._back();\n            next();\n          });\n        }, function (err) {\n          callback(err, post);\n        });\n      }\n      return post;\n    }\n  };\n\n  // Sanitization Class --------------------------------------------------------\n  // inherits from Inspection class (actually we just call Inspection\n  // constructor with the new context, because its prototype is empty\n  function Sanitization(schema, custom) {\n    Inspection.prototype.constructor.call(this, schema, _merge(Sanitization.custom, custom));\n    var _reporting = [];\n\n    this._basicFields = Object.keys(_sanitizationAttribut);\n    this._customFields = Object.keys(this._custom);\n    this.origin = null;\n\n    this.report = function (message) {\n      var newNot = {\n        message: message || 'was sanitized',\n        property: this.userAlias ? (this.userAlias + ' (' + this._dumpStack() + ')') : this._dumpStack()\n      };\n      if (!_reporting.some(function (e) { return e.property === newNot.property; })) {\n        _reporting.push(newNot);\n      }\n    };\n\n    this.result = function (data) {\n      // For old IE.\n      /* eslint-disable object-shorthand */\n      return {\n        data: data,\n        reporting: _reporting,\n        format: function () {\n          return this.reporting.map(function (i) {\n            return 'Property ' + i.property + ' ' + i.message;\n          }).join('\\n');\n        }\n      };\n      /* eslint-enable object-shorthand */\n    };\n  }\n\n  _extend(Sanitization.prototype, _sanitizationAttribut);\n  _extend(Sanitization.prototype, _asyncSanitizationAttribut);\n  _extend(Sanitization, new Customisable());\n\n  Sanitization.prototype.sanitize = function (post, callback) {\n    this.origin = post;\n    if (typeof callback === 'function') {\n      var self = this;\n      return this._asyncSanitize(this._schema, post, function (err, data) {\n        self.origin = null;\n        callback(err, self.result(data));\n      });\n    }\n    var data = this._sanitize(this._schema, post);\n    this.origin = null;\n    return this.result(data);\n  };\n\n  Sanitization.prototype._sanitize = function (schema, post) {\n    this.userAlias = schema.alias || null;\n    this._basicFields.forEach(function (i) {\n      if ((i in schema || i === 'optional') && typeof this[i] === 'function') {\n        post = this[i](schema, post);\n      }\n    }, this);\n    this._customFields.forEach(function (i) {\n      if (i in schema && typeof this._custom[i] === 'function') {\n        post = this._custom[i].call(this, schema, post);\n      }\n    }, this);\n    return post;\n  };\n\n  Sanitization.prototype._asyncSanitize = function (schema, post, callback) {\n    var self = this;\n    this.userAlias = schema.alias || null;\n\n    async.waterfall([\n      function (next) {\n        async.reduce(self._basicFields, post, function (value, i, next) {\n          async.nextTick(function () {\n            if ((i in schema || i === 'optional') && typeof self[i] === 'function') {\n              if (self[i].length > 2) {\n                return self[i](schema, value, next);\n              }\n              value = self[i](schema, value);\n            }\n            next(null, value);\n          });\n        }, next);\n      },\n      function (inter, next) {\n        async.reduce(self._customFields, inter, function (value, i, next) {\n          async.nextTick(function () {\n            if (i in schema && typeof self._custom[i] === 'function') {\n              if (self._custom[i].length > 2) {\n                return self._custom[i].call(self, schema, value, next);\n              }\n              value = self._custom[i].call(self, schema, value);\n            }\n            next(null, value);\n          });\n        }, next);\n      }\n    ], callback);\n  };\n\n  // ---------------------------------------------------------------------------\n\n  var INT_MIN = -2147483648;\n  var INT_MAX = 2147483647;\n\n  var _rand = {\n    int: function (min, max) {\n      return min + (0 | Math.random() * (max - min + 1));\n    },\n    float: function (min, max) {\n      return (Math.random() * (max - min) + min);\n    },\n    bool: function () {\n      return (Math.random() > 0.5);\n    },\n    char: function (min, max) {\n      return String.fromCharCode(this.int(min, max));\n    },\n    fromList: function (list) {\n      return list[this.int(0, list.length - 1)];\n    }\n  };\n\n  var _formatSample = {\n    'date-time': function () {\n      return new Date().toISOString();\n    },\n    date: function () {\n      return new Date().toISOString().replace(/T.*$/, '');\n    },\n    time: function () {\n      return new Date().toLocaleTimeString({}, { hour12: false });\n    },\n    color: function (min, max) {\n      var s = '#';\n      if (min < 1) {\n        min = 1;\n      }\n      for (var i = 0, l = _rand.int(min, max); i < l; i++) {\n        s += _rand.fromList('0123456789abcdefABCDEF');\n      }\n      return s;\n    },\n    numeric: function () {\n      return '' + _rand.int(0, INT_MAX);\n    },\n    integer: function () {\n      if (_rand.bool() === true) {\n        return '-' + this.numeric();\n      }\n      return this.numeric();\n    },\n    decimal: function () {\n      return this.integer() + '.' + this.numeric();\n    },\n    alpha: function (min, max) {\n      var s = '';\n      if (min < 1) {\n        min = 1;\n      }\n      for (var i = 0, l = _rand.int(min, max); i < l; i++) {\n        s += _rand.fromList('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ');\n      }\n      return s;\n    },\n    alphaNumeric: function (min, max) {\n      var s = '';\n      if (min < 1) {\n        min = 1;\n      }\n      for (var i = 0, l = _rand.int(min, max); i < l; i++) {\n        s += _rand.fromList('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789');\n      }\n      return s;\n    },\n    alphaDash: function (min, max) {\n      var s = '';\n      if (min < 1) {\n        min = 1;\n      }\n      for (var i = 0, l = _rand.int(min, max); i < l; i++) {\n        s += _rand.fromList('_-abcdefghijklmnopqrstuvwxyz_-ABCDEFGHIJKLMNOPQRSTUVWXYZ_-0123456789_-');\n      }\n      return s;\n    },\n    javascript: function (min, max) {\n      var s = _rand.fromList('_$abcdefghijklmnopqrstuvwxyz_$ABCDEFGHIJKLMNOPQRSTUVWXYZ_$');\n      for (var i = 0, l = _rand.int(min, max - 1); i < l; i++) {\n        s += _rand.fromList('_$abcdefghijklmnopqrstuvwxyz_$ABCDEFGHIJKLMNOPQRSTUVWXYZ_$0123456789_$');\n      }\n      return s;\n    }\n  };\n\n  function _getLimits(schema) {\n    var min = INT_MIN;\n    var max = INT_MAX;\n\n    if (schema.gte != null) {\n      min = schema.gte;\n    } else if (schema.gt != null) {\n      min = schema.gt + 1;\n    }\n    if (schema.lte != null) {\n      max = schema.lte;\n    } else if (schema.lt != null) {\n      max = schema.lt - 1;\n    }\n    // For old IE.\n    /* eslint-disable object-shorthand */\n    return { min: min, max: max };\n    /* eslint-enable object-shorthand */\n  }\n\n  var _typeGenerator = {\n    string: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n      var s = '';\n      var minLength = schema.minLength != null ? schema.minLength : 0;\n      var maxLength = schema.maxLength != null ? schema.maxLength : 32;\n      if (typeof schema.pattern === 'string' && typeof _formatSample[schema.pattern] === 'function') {\n        return _formatSample[schema.pattern](minLength, maxLength);\n      }\n\n      var l = schema.exactLength != null ? schema.exactLength : _rand.int(minLength, maxLength);\n      for (var i = 0; i < l; i++) {\n        s += _rand.char(32, 126);\n      }\n      return s;\n    },\n    number: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n      var limit = _getLimits(schema);\n      var n = _rand.float(limit.min, limit.max);\n      if (schema.ne != null) {\n        var ne = _typeIs.array(schema.ne) ? schema.ne : [schema.ne];\n        while (ne.indexOf(n) !== -1) {\n          n = _rand.float(limit.min, limit.max);\n        }\n      }\n      return n;\n    },\n    integer: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n      var limit = _getLimits(schema);\n      var n = _rand.int(limit.min, limit.max);\n      if (schema.ne != null) {\n        var ne = _typeIs.array(schema.ne) ? schema.ne : [schema.ne];\n        while (ne.indexOf(n) !== -1) {\n          n = _rand.int(limit.min, limit.max);\n        }\n      }\n      return n;\n    },\n    boolean: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n      return _rand.bool();\n    },\n    null: function (schema) {\n      return null;\n    },\n    date: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n      return new Date();\n    },\n    object: function (schema) {\n      var o = {};\n      var prop = schema.properties || {};\n\n      for (var key in prop) {\n        if (Object.prototype.hasOwnProperty.call(prop, key)) {\n          if (prop[key].optional === true && _rand.bool() === true) {\n            continue;\n          }\n          if (key !== '*') {\n            o[key] = this.generate(prop[key]);\n          } else {\n            var rk = '__random_key_';\n            var randomKey = rk + 0;\n            var n = _rand.int(1, 9);\n            for (var i = 1; i <= n; i++) {\n              if (!(randomKey in prop)) {\n                o[randomKey] = this.generate(prop[key]);\n              }\n              randomKey = rk + i;\n            }\n          }\n        }\n      }\n      return o;\n    },\n    array: function (schema) {\n      var self = this;\n      var items = schema.items || {};\n      var minLength = schema.minLength != null ? schema.minLength : 0;\n      var maxLength = schema.maxLength != null ? schema.maxLength : 16;\n      var type;\n      var candidate;\n      var size;\n      var i;\n\n      if (_typeIs.array(items)) {\n        size = items.length;\n        if (schema.exactLength != null) {\n          size = schema.exactLength;\n        } else if (size < minLength) {\n          size = minLength;\n        } else if (size > maxLength) {\n          size = maxLength;\n        }\n        candidate = new Array(size);\n        type = null;\n        for (i = 0; i < size; i++) {\n          type = items[i].type || 'any';\n          if (_typeIs.array(type)) {\n            type = type[_rand.int(0, type.length - 1)];\n          }\n          candidate[i] = self[type](items[i]);\n        }\n      } else {\n        size = schema.exactLength != null ? schema.exactLength : _rand.int(minLength, maxLength);\n        candidate = new Array(size);\n        type = items.type || 'any';\n        if (_typeIs.array(type)) {\n          type = type[_rand.int(0, type.length - 1)];\n        }\n        for (i = 0; i < size; i++) {\n          candidate[i] = self[type](items);\n        }\n      }\n      return candidate;\n    },\n    any: function (schema) {\n      var fields = Object.keys(_typeGenerator);\n      var i = fields[_rand.int(0, fields.length - 2)];\n      return this[i](schema);\n    }\n  };\n\n  // CandidateGenerator Class (Singleton) --------------------------------------\n  function CandidateGenerator() {\n    // Maybe extends Inspection class too ?\n  }\n\n  _extend(CandidateGenerator.prototype, _typeGenerator);\n\n  var _instance = null;\n  CandidateGenerator.instance = function () {\n    if (!(_instance instanceof CandidateGenerator)) {\n      _instance = new CandidateGenerator();\n    }\n    return _instance;\n  };\n\n  CandidateGenerator.prototype.generate = function (schema) {\n    var type = schema.type || 'any';\n    if (_typeIs.array(type)) {\n      type = type[_rand.int(0, type.length - 1)];\n    }\n    return this[type](schema);\n  };\n\n  // Exports ---------------------------------------------------------------------\n  var SchemaInspector = {};\n\n  // if server-side (node.js) else client-side\n  if ( true && module.exports) {\n    module.exports = SchemaInspector;\n  } else {\n    window.SchemaInspector = SchemaInspector;\n  }\n\n  SchemaInspector.newSanitization = function (schema, custom) {\n    return new Sanitization(schema, custom);\n  };\n\n  SchemaInspector.newValidation = function (schema, custom) {\n    return new Validation(schema, custom);\n  };\n\n  SchemaInspector.Validation = Validation;\n  SchemaInspector.Sanitization = Sanitization;\n\n  SchemaInspector.sanitize = function (schema, post, custom, callback) {\n    if (arguments.length === 3 && typeof custom === 'function') {\n      callback = custom;\n      custom = null;\n    }\n    return new Sanitization(schema, custom).sanitize(post, callback);\n  };\n\n  SchemaInspector.validate = function (schema, candidate, custom, callback) {\n    if (arguments.length === 3 && typeof custom === 'function') {\n      callback = custom;\n      custom = null;\n    }\n    return new Validation(schema, custom).validate(candidate, callback);\n  };\n\n  SchemaInspector.generate = function (schema, n) {\n    if (typeof n === 'number') {\n      var r = new Array(n);\n      for (var i = 0; i < n; i++) {\n        r[i] = CandidateGenerator.instance().generate(schema);\n      }\n      return r;\n    }\n    return CandidateGenerator.instance().generate(schema);\n  };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2NoZW1hLWluc3BlY3Rvci9saWIvc2NoZW1hLWluc3BlY3Rvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBNkIsSUFBSSxtQkFBTyxDQUFDLHVEQUFPLElBQUksQ0FBWTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1Qyx1REFBdUQ7QUFDOUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxFQUFFLGtCQUFrQixrckJBQWtyQixFQUFFLGtCQUFrQixvRkFBb0YsRUFBRSxrQkFBa0IsMkZBQTJGLEVBQUUsa0JBQWtCLDhHQUE4RyxFQUFFLGtCQUFrQjtBQUMxcEMsc0JBQXNCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsZUFBZSxFQUFFLElBQUksRUFBRTtBQUNyRixlQUFlLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtBQUM3Qix1QkFBdUIsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRTtBQUM3RSxlQUFlLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLFVBQVUsRUFBRSxVQUFVLEdBQUc7QUFDL0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7O0FBRXZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EseUNBQXlDLGtFQUFrRTtBQUMzRztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0NBQStDLHVCQUF1QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUixvQkFBb0I7QUFDcEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0NBQXdDO0FBQ2xGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2Q0FBNkMsSUFBSSxlQUFlO0FBQ2hFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sS0FBNkI7QUFDbkM7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ZvaWNlLXN0YWJsZXMtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvc2NoZW1hLWluc3BlY3Rvci9saWIvc2NoZW1hLWluc3BlY3Rvci5qcz81ODMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIERpc2FibGUgbm8tdmFyIGJlY2F1c2Ugd2UgbmVlZCB0byBzdXBwb3J0IG9sZCBJRSBmb3Igbm93LlxuLyogZXNsaW50LWRpc2FibGUgbm8tdmFyICovXG4vLyBEaXNhYmxlIHNwYWNlLWJlZm9yZS1mdW5jdGlvbi1wYXJlbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIFZTIENvZGUgZGVmYXVsdCBKUyBmb3JtYXR0ZXIuXG4vKiBlc2xpbnQtZGlzYWJsZSBzcGFjZS1iZWZvcmUtZnVuY3Rpb24tcGFyZW4gKi9cblxuLypcbiAqIFRoaXMgbW9kdWxlIGlzIGludGVuZGVkIHRvIGJlIGV4ZWN1dGVkIGJvdGggb24gY2xpZW50IHNpZGUgYW5kIHNlcnZlciBzaWRlLlxuICogTm8gZXJyb3Igc2hvdWxkIGJlIHRocm93bi4gKHNvZnQgZXJyb3IgaGFuZGxpbmcpXG4gKi9cblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJvb3QgPSB7fTtcbiAgLy8gRGVwZW5kZW5jaWVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJvb3QuYXN5bmMgPSAodHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpID8gcmVxdWlyZSgnYXN5bmMnKSA6IHdpbmRvdy5hc3luYztcbiAgaWYgKHR5cGVvZiByb290LmFzeW5jICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignTW9kdWxlIGFzeW5jIGlzIHJlcXVpcmVkIChodHRwczovL2dpdGh1Yi5jb20vY2FvbGFuL2FzeW5jKScpO1xuICB9XG4gIHZhciBhc3luYyA9IHJvb3QuYXN5bmM7XG5cbiAgZnVuY3Rpb24gX2V4dGVuZChvcmlnaW4sIGFkZCkge1xuICAgIGlmICghYWRkIHx8IHR5cGVvZiBhZGQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH1cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gICAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvcmlnaW47XG4gIH1cblxuICBmdW5jdGlvbiBfbWVyZ2UoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIga2V5cyA9IG51bGw7XG4gICAgdmFyIGkgPSBudWxsO1xuXG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIGlmIChhcmcgJiYgYXJnLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGFyZyk7XG4gICAgICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHJldFtrZXlzW2ldXSA9IGFyZ1trZXlzW2ldXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBDdXN0b21pc2FibGUgY2xhc3MgKEJhc2UgY2xhc3MpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gVXNlIHdpdGggb3BlcmF0aW9uIFwibmV3XCIgdG8gZXh0ZW5kIFZhbGlkYXRpb24gYW5kIFNhbml0aXphdGlvbiB0aGVtc2VsdmVzLFxuICAvLyBub3QgdGhlaXIgcHJvdG90eXBlLiBJbiBvdGhlciB3b3JkcywgY29uc3RydWN0b3Igc2hhbGwgYmUgY2FsbCB0byBleHRlbmRcbiAgLy8gdGhvc2UgZnVuY3Rpb25zLCBpbnN0ZWFkIG9mIGJlaW5nIGluIHRoZWlyIGNvbnN0cnVjdG9yLCBsaWtlIHRoaXM6XG4gIC8vICAgX2V4dGVuZChWYWxpZGF0aW9uLCBuZXcgQ3VzdG9taXNhYmxlKTtcblxuICBmdW5jdGlvbiBDdXN0b21pc2FibGUoKSB7XG4gICAgdGhpcy5jdXN0b20gPSB7fTtcblxuICAgIHRoaXMuZXh0ZW5kID0gZnVuY3Rpb24gKGN1c3RvbSkge1xuICAgICAgcmV0dXJuIF9leHRlbmQodGhpcy5jdXN0b20sIGN1c3RvbSk7XG4gICAgfTtcblxuICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmN1c3RvbSA9IHt9O1xuICAgIH07XG5cbiAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uIChmaWVsZHMpIHtcbiAgICAgIGlmICghX3R5cGVJcy5hcnJheShmaWVsZHMpKSB7XG4gICAgICAgIGZpZWxkcyA9IFtmaWVsZHNdO1xuICAgICAgfVxuICAgICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmN1c3RvbVtmaWVsZF07XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gSW5zcGVjdGlvbiBjbGFzcyAoQmFzZSBjbGFzcykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFVzZSB0byBleHRlbmQgVmFsaWRhdGlvbiBhbmQgU2FuaXRpemF0aW9uIHByb3RvdHlwZXMuIEluc3BlY3Rpb25cbiAgLy8gY29uc3RydWN0b3Igc2hhbGwgYmUgY2FsbGVkIGluIGRlcml2ZWQgY2xhc3MgY29uc3RydWN0b3IuXG5cbiAgZnVuY3Rpb24gSW5zcGVjdGlvbihzY2hlbWEsIGN1c3RvbSkge1xuICAgIHZhciBfc3RhY2sgPSBbJ0AnXTtcblxuICAgIHRoaXMuX3NjaGVtYSA9IHNjaGVtYTtcbiAgICB0aGlzLl9jdXN0b20gPSB7fTtcbiAgICBpZiAoY3VzdG9tICE9IG51bGwpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBjdXN0b20pIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjdXN0b20sIGtleSkpIHtcbiAgICAgICAgICB0aGlzLl9jdXN0b21bJyQnICsga2V5XSA9IGN1c3RvbVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fZ2V0RGVwdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3N0YWNrLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgdGhpcy5fZHVtcFN0YWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29udHJvbC1yZWdleCAqL1xuICAgICAgcmV0dXJuIF9zdGFjay5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkucmVwbGFjZSgvXlxcWy9nLCAnXFx1MDAxYlxcdTAwMWNcXHUwMDFkXFx1MDAxZScpOyB9KVxuICAgICAgICAuam9pbignLicpLnJlcGxhY2UoL1xcLlxcdTAwMWJcXHUwMDFjXFx1MDAxZFxcdTAwMWUvZywgJ1snKTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29udHJvbC1yZWdleCAqL1xuICAgIH07XG5cbiAgICB0aGlzLl9kZWVwZXJPYmplY3QgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgX3N0YWNrLnB1c2goKC9eW2EteiRfXVthLXowLTkkX10qJC9pKS50ZXN0KG5hbWUpID8gbmFtZSA6ICdbXCInICsgbmFtZSArICdcIl0nKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLl9kZWVwZXJBcnJheSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICBfc3RhY2sucHVzaCgnWycgKyBpICsgJ10nKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLl9iYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3N0YWNrLnBvcCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfVxuICAvLyBTaW1wbGUgdHlwZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgdGhlIHByb3BlcnR5IGlzIG5vdCBkZWZpbmVkIG9yIGlzIG5vdCBpbiB0aGlzIGxpc3Q6XG4gIHZhciBfdHlwZUlzID0ge1xuICAgIGZ1bmN0aW9uOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBlbGVtZW50ID09PSAnZnVuY3Rpb24nO1xuICAgIH0sXG4gICAgc3RyaW5nOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJztcbiAgICB9LFxuICAgIG51bWJlcjogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKGVsZW1lbnQpO1xuICAgIH0sXG4gICAgaW50ZWdlcjogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicgJiYgZWxlbWVudCAlIDEgPT09IDA7XG4gICAgfSxcbiAgICBOYU46IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInICYmIGlzTmFOKGVsZW1lbnQpO1xuICAgIH0sXG4gICAgYm9vbGVhbjogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZWxlbWVudCA9PT0gJ2Jvb2xlYW4nO1xuICAgIH0sXG4gICAgbnVsbDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50ID09PSBudWxsO1xuICAgIH0sXG4gICAgZGF0ZTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50ICE9IG51bGwgJiYgZWxlbWVudCBpbnN0YW5jZW9mIERhdGU7XG4gICAgfSxcbiAgICBvYmplY3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmIGVsZW1lbnQgIT0gbnVsbCAmJiBlbGVtZW50LmNvbnN0cnVjdG9yICE9PSBBcnJheTtcbiAgICB9LFxuICAgIGFycmF5OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQgIT0gbnVsbCAmJiBlbGVtZW50LmNvbnN0cnVjdG9yID09PSBBcnJheTtcbiAgICB9LFxuICAgIGFueTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIF9zaW1wbGVUeXBlKHR5cGUsIGNhbmRpZGF0ZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGNhbmRpZGF0ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICAgIHR5cGUgPSB0eXBlIGluIF90eXBlSXMgPyB0eXBlIDogJ2FueSc7XG4gICAgcmV0dXJuIF90eXBlSXNbdHlwZV0oY2FuZGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9yZWFsVHlwZShjYW5kaWRhdGUpIHtcbiAgICBmb3IgKHZhciBpIGluIF90eXBlSXMpIHtcbiAgICAgIGlmIChfc2ltcGxlVHlwZShpLCBjYW5kaWRhdGUpKSB7XG4gICAgICAgIGlmIChpICE9PSAnYW55JyAmJiAoaSAhPT0gJ29iamVjdCcgfHwgY2FuZGlkYXRlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpKSB7IHJldHVybiBpOyB9XG4gICAgICAgIHJldHVybiAnYW4gaW5zdGFuY2Ugb2YgJyArIGNhbmRpZGF0ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEluZGV4ZXMoYSwgdmFsdWUpIHtcbiAgICB2YXIgaW5kZXhlcyA9IFtdO1xuICAgIHZhciBpID0gYS5pbmRleE9mKHZhbHVlKTtcblxuICAgIHdoaWxlIChpICE9PSAtMSkge1xuICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgaSA9IGEuaW5kZXhPZih2YWx1ZSwgaSArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXhlcztcbiAgfVxuXG4gIC8vIEF2YWlsYWJsZSBmb3JtYXRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11c2VsZXNzLWVzY2FwZSAqL1xuICAvLyBUT0RPOiBTdHVkeSB0aGVzZSByZWdleCBleHByZXNzaW9ucyBhbmQgYWRkIG1vcmUgdGVzdHMgc28gd2UgY2FuIGNvbnNpZGVyIHJlbW92aW5nXG4gIC8vIHJ1bGUgbm8tdXNlbGVzcy1lc2NhcGUuXG4gIHZhciBfZm9ybWF0cyA9IHtcbiAgICB2b2lkOiAvXiQvLFxuICAgIHVybDogL14oaHR0cHM/fGZ0cCk6XFwvXFwvKCgoKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDopKkApPygoKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKSl8KCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLik/KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuPykoOlxcZCopPykoXFwvKCgoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKSsoXFwvKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApKikqKT8pPyhcXD8oKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApfFtcXHVFMDAwLVxcdUY4RkZdfFxcL3xcXD8pKik/KFxcIygoKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCl8XFwvfFxcPykqKT8kL2ksXG4gICAgJ2RhdGUtdGltZSc6IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfTpcXGR7Mn0oXFwuXFxkezN9KT8oWj98KC18XFwrKVxcZHsyfTpcXGR7Mn0pJC8sXG4gICAgZGF0ZTogL15cXGR7NH0tXFxkezJ9LVxcZHsyfSQvLFxuICAgIGNvb2xEYXRlVGltZTogL15cXGR7NH0oLXxcXC8pXFxkezJ9KC18XFwvKVxcZHsyfShUfCApXFxkezJ9OlxcZHsyfTpcXGR7Mn0oXFwuXFxkezN9KT9aPyQvLFxuICAgIHRpbWU6IC9eXFxkezJ9XFw6XFxkezJ9XFw6XFxkezJ9JC8sXG4gICAgY29sb3I6IC9eIyhbMC05YS1mXSkrJC9pLFxuICAgIC8vIFZlcnkgZmxleGlibGUgcmVndWxhciBleHByZXNzaW9uIGRlc2lnbmVkIHRvIGNhdGNoIG9ubHkgb2J2aW91cyBtaXN0YWtlc1xuICAgIC8vIHRoYXQgYSB1c2VyIG1pZ2h0IG1ha2UgdGhhdCB3b3VsZCBoYXZlIGEgMTAwJSBjaGFuY2Ugb2YgY2F1c2luZyBlbWFpbFxuICAgIC8vIGRlbGl2ZXJ5IHRvIHRoZSBhZGRyZXNzIHRvIGZhaWwuIFRoZSBsaWJyYXJ5IHRha2VzIGEgZmxleGlibGUgb3ZlclxuICAgIC8vIHN0cmljdCBhcHByb2FjaC4gVXNlcnMgc2hvdWxkIHVzZSB0aGlzIG9ubHkgZm9yIGJhc2ljIGZyb250IGVuZCBlbWFpbFxuICAgIC8vIGFkZHJlc3MgdmFsaWRhdGlvbiBhbmQgcGVyZm9ybSBtb3JlIHN0cmljdCBjaGVja2luZyB1c2luZyBzZXJ2ZXItc2lkZVxuICAgIC8vIGNvZGUgYWZ0ZXIgdGhlIGRhdGEgaGFzIGJlZW4gc2VudCB0byB0aGVpciBzZXJ2ZXIuXG4gICAgLy8gU291cmNlZCBmcm9tIGh0dHBzOi8vd3d3LnJlZ3VsYXItZXhwcmVzc2lvbnMuaW5mby9lbWFpbC5odG1sLCBtb2RpZmllZFxuICAgIC8vIHRvIGFsbG93IGxvd2VyY2FzZSBjaGFyYWN0ZXJzIHRvby5cbiAgICBlbWFpbDogL15bXkBdK0BbXi5dK1xcLlthLXpBLVpdKyQvLFxuICAgIC8qIGVzbGludC1lbmFibGUgcHJlZmVyLXJlZ2V4LWxpdGVyYWxzICovXG4gICAgLyogZXNsaW50LWVuYWJsZSBxdW90ZXMgKi9cbiAgICBudW1lcmljOiAvXlswLTldKyQvLFxuICAgIGludGVnZXI6IC9eXFwtP1swLTldKyQvLFxuICAgIGRlY2ltYWw6IC9eXFwtP1swLTldKlxcLj9bMC05XSskLyxcbiAgICBhbHBoYTogL15bYS16XSskL2ksXG4gICAgYWxwaGFOdW1lcmljOiAvXlthLXowLTldKyQvaSxcbiAgICBhbHBoYURhc2g6IC9eW2EtejAtOV8tXSskL2ksXG4gICAgamF2YXNjcmlwdDogL15bYS16X1xcJF1bYS16MC05X1xcJF0qJC9pLFxuICAgIHVwcGVyU3RyaW5nOiAvXltBLVogXSokLyxcbiAgICBsb3dlclN0cmluZzogL15bYS16IF0qJC8sXG4gICAgdjR1dWlkOiAvXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzAtOWEtZl17NH0tWzAtOWEtZl17MTJ9JC9pXG4gIH07XG4gIC8qIGVzbGludC1lbmFibGUgbm8tdXNlbGVzcy1lc2NhcGUgKi9cblxuICAvLyBWYWxpZGF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgX3ZhbGlkYXRpb25BdHRyaWJ1dCA9IHtcbiAgICBvcHRpb25hbDogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlKSB7XG4gICAgICB2YXIgb3B0ID0gdHlwZW9mIHNjaGVtYS5vcHRpb25hbCA9PT0gJ2Jvb2xlYW4nID8gc2NoZW1hLm9wdGlvbmFsIDogKHNjaGVtYS5vcHRpb25hbCA9PT0gJ3RydWUnKTsgLy8gRGVmYXVsdCBpcyBmYWxzZVxuXG4gICAgICBpZiAob3B0ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY2FuZGlkYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnJlcG9ydCgnaXMgbWlzc2luZyBhbmQgbm90IG9wdGlvbmFsJywgbnVsbCwgJ29wdGlvbmFsJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0eXBlOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUpIHtcbiAgICAgIC8vIHJldHVybiBiZWNhdXNlIG9wdGlvbmFsIGZ1bmN0aW9uIGFscmVhZHkgaGFuZGxlIHRoaXMgY2FzZVxuICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgPT09ICd1bmRlZmluZWQnIHx8ICh0eXBlb2Ygc2NoZW1hLnR5cGUgIT09ICdzdHJpbmcnICYmICEoc2NoZW1hLnR5cGUgaW5zdGFuY2VvZiBBcnJheSkgJiYgdHlwZW9mIHNjaGVtYS50eXBlICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdHlwZXMgPSBfdHlwZUlzLmFycmF5KHNjaGVtYS50eXBlKSA/IHNjaGVtYS50eXBlIDogW3NjaGVtYS50eXBlXTtcbiAgICAgIHZhciB0eXBlSXNWYWxpZCA9IHR5cGVzLnNvbWUoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIF9zaW1wbGVUeXBlKHR5cGUsIGNhbmRpZGF0ZSk7XG4gICAgICB9KTtcbiAgICAgIGlmICghdHlwZUlzVmFsaWQpIHtcbiAgICAgICAgdHlwZXMgPSB0eXBlcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHR5cGVvZiB0ID09PSAnZnVuY3Rpb24nID8gJ2FuIGluc3RhbmNlIG9mICcgKyB0Lm5hbWUgOiB0OyB9KTtcbiAgICAgICAgdGhpcy5yZXBvcnQoJ211c3QgYmUgJyArIHR5cGVzLmpvaW4oJyBvciAnKSArICcsIGJ1dCBpcyAnICsgX3JlYWxUeXBlKGNhbmRpZGF0ZSksIG51bGwsICd0eXBlJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB1bmlxdWVuZXNzOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLnVuaXF1ZW5lc3MgPT09ICdzdHJpbmcnKSB7IHNjaGVtYS51bmlxdWVuZXNzID0gKHNjaGVtYS51bmlxdWVuZXNzID09PSAndHJ1ZScpOyB9XG4gICAgICBpZiAodHlwZW9mIHNjaGVtYS51bmlxdWVuZXNzICE9PSAnYm9vbGVhbicgfHwgc2NoZW1hLnVuaXF1ZW5lc3MgPT09IGZhbHNlIHx8ICghX3R5cGVJcy5hcnJheShjYW5kaWRhdGUpICYmIHR5cGVvZiBjYW5kaWRhdGUgIT09ICdzdHJpbmcnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmVwb3J0ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FuZGlkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZXBvcnRlZC5pbmRleE9mKGNhbmRpZGF0ZVtpXSkgPj0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleGVzID0gZ2V0SW5kZXhlcyhjYW5kaWRhdGUsIGNhbmRpZGF0ZVtpXSk7XG4gICAgICAgIGlmIChpbmRleGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXBvcnRlZC5wdXNoKGNhbmRpZGF0ZVtpXSk7XG4gICAgICAgICAgdGhpcy5yZXBvcnQoJ2hhcyB2YWx1ZSBbJyArIGNhbmRpZGF0ZVtpXSArICddIG1vcmUgdGhhbiBvbmNlIGF0IGluZGV4ZXMgWycgKyBpbmRleGVzLmpvaW4oJywgJykgKyAnXScsIG51bGwsICd1bmlxdWVuZXNzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHBhdHRlcm46IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHJlZ2V4cyA9IHNjaGVtYS5wYXR0ZXJuO1xuICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBtYXRjaGVzID0gZmFsc2U7XG4gICAgICBpZiAoIV90eXBlSXMuYXJyYXkocmVnZXhzKSkge1xuICAgICAgICByZWdleHMgPSBbcmVnZXhzXTtcbiAgICAgIH1cbiAgICAgIHJlZ2V4cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWdleCkge1xuICAgICAgICBpZiAodHlwZW9mIHJlZ2V4ID09PSAnc3RyaW5nJyAmJiByZWdleCBpbiBfZm9ybWF0cykge1xuICAgICAgICAgIHJlZ2V4ID0gX2Zvcm1hdHNbcmVnZXhdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgIGlmIChyZWdleC50ZXN0KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgIG1hdGNoZXMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgc2VsZi5yZXBvcnQoJ211c3QgbWF0Y2ggWycgKyByZWdleHMuam9pbignIG9yICcpICsgJ10sIGJ1dCBpcyBlcXVhbCB0byBcIicgKyBjYW5kaWRhdGUgKyAnXCInLCBudWxsLCAncGF0dGVybicpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWREYXRlOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUpIHtcbiAgICAgIGlmIChTdHJpbmcoc2NoZW1hLnZhbGlkRGF0ZSkgPT09ICd0cnVlJyAmJiBjYW5kaWRhdGUgaW5zdGFuY2VvZiBEYXRlICYmIGlzTmFOKGNhbmRpZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHRoaXMucmVwb3J0KCdtdXN0IGJlIGEgdmFsaWQgZGF0ZScsIG51bGwsICd2YWxpZERhdGUnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1pbkxlbmd0aDogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZSAhPT0gJ3N0cmluZycgJiYgIV90eXBlSXMuYXJyYXkoY2FuZGlkYXRlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbWluTGVuZ3RoID0gTnVtYmVyKHNjaGVtYS5taW5MZW5ndGgpO1xuICAgICAgaWYgKGlzTmFOKG1pbkxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNhbmRpZGF0ZS5sZW5ndGggPCBtaW5MZW5ndGgpIHtcbiAgICAgICAgdGhpcy5yZXBvcnQoJ211c3QgYmUgbG9uZ2VyIHRoYW4gJyArIG1pbkxlbmd0aCArICcgZWxlbWVudHMsIGJ1dCBpdCBoYXMgJyArIGNhbmRpZGF0ZS5sZW5ndGgsIG51bGwsICdtaW5MZW5ndGgnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1heExlbmd0aDogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZSAhPT0gJ3N0cmluZycgJiYgIV90eXBlSXMuYXJyYXkoY2FuZGlkYXRlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbWF4TGVuZ3RoID0gTnVtYmVyKHNjaGVtYS5tYXhMZW5ndGgpO1xuICAgICAgaWYgKGlzTmFOKG1heExlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNhbmRpZGF0ZS5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5yZXBvcnQoJ211c3QgYmUgc2hvcnRlciB0aGFuICcgKyBtYXhMZW5ndGggKyAnIGVsZW1lbnRzLCBidXQgaXQgaGFzICcgKyBjYW5kaWRhdGUubGVuZ3RoLCBudWxsLCAnbWF4TGVuZ3RoJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBleGFjdExlbmd0aDogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZSAhPT0gJ3N0cmluZycgJiYgIV90eXBlSXMuYXJyYXkoY2FuZGlkYXRlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZXhhY3RMZW5ndGggPSBOdW1iZXIoc2NoZW1hLmV4YWN0TGVuZ3RoKTtcbiAgICAgIGlmIChpc05hTihleGFjdExlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNhbmRpZGF0ZS5sZW5ndGggIT09IGV4YWN0TGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucmVwb3J0KCdtdXN0IGhhdmUgZXhhY3RseSAnICsgZXhhY3RMZW5ndGggKyAnIGVsZW1lbnRzLCBidXQgaXQgaGF2ZSAnICsgY2FuZGlkYXRlLmxlbmd0aCwgbnVsbCwgJ2V4YWN0TGVuZ3RoJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsdDogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlKSB7XG4gICAgICB2YXIgbGltaXQgPSBOdW1iZXIoc2NoZW1hLmx0KTtcbiAgICAgIGlmICh0eXBlb2YgY2FuZGlkYXRlICE9PSAnbnVtYmVyJyB8fCBpc05hTihsaW1pdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNhbmRpZGF0ZSA+PSBsaW1pdCkge1xuICAgICAgICB0aGlzLnJlcG9ydCgnbXVzdCBiZSBsZXNzIHRoYW4gJyArIGxpbWl0ICsgJywgYnV0IGlzIGVxdWFsIHRvIFwiJyArIGNhbmRpZGF0ZSArICdcIicsIG51bGwsICdsdCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbHRlOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUpIHtcbiAgICAgIHZhciBsaW1pdCA9IE51bWJlcihzY2hlbWEubHRlKTtcbiAgICAgIGlmICh0eXBlb2YgY2FuZGlkYXRlICE9PSAnbnVtYmVyJyB8fCBpc05hTihsaW1pdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNhbmRpZGF0ZSA+IGxpbWl0KSB7XG4gICAgICAgIHRoaXMucmVwb3J0KCdtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAnICsgbGltaXQgKyAnLCBidXQgaXMgZXF1YWwgdG8gXCInICsgY2FuZGlkYXRlICsgJ1wiJywgbnVsbCwgJ2x0ZScpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ3Q6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSkge1xuICAgICAgdmFyIGxpbWl0ID0gTnVtYmVyKHNjaGVtYS5ndCk7XG4gICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZSAhPT0gJ251bWJlcicgfHwgaXNOYU4obGltaXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGUgPD0gbGltaXQpIHtcbiAgICAgICAgdGhpcy5yZXBvcnQoJ211c3QgYmUgZ3JlYXRlciB0aGFuICcgKyBsaW1pdCArICcsIGJ1dCBpcyBlcXVhbCB0byBcIicgKyBjYW5kaWRhdGUgKyAnXCInLCBudWxsLCAnZ3QnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGd0ZTogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlKSB7XG4gICAgICB2YXIgbGltaXQgPSBOdW1iZXIoc2NoZW1hLmd0ZSk7XG4gICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZSAhPT0gJ251bWJlcicgfHwgaXNOYU4obGltaXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGUgPCBsaW1pdCkge1xuICAgICAgICB0aGlzLnJlcG9ydCgnbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJyArIGxpbWl0ICsgJywgYnV0IGlzIGVxdWFsIHRvIFwiJyArIGNhbmRpZGF0ZSArICdcIicsIG51bGwsICdndGUnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVxOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FuZGlkYXRlICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgY2FuZGlkYXRlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgY2FuZGlkYXRlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGxpbWl0ID0gc2NoZW1hLmVxO1xuICAgICAgaWYgKHR5cGVvZiBsaW1pdCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGxpbWl0ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgbGltaXQgIT09ICdib29sZWFuJyAmJiAhX3R5cGVJcy5hcnJheShsaW1pdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKF90eXBlSXMuYXJyYXkobGltaXQpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGltaXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlID09PSBsaW1pdFtpXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcG9ydCgnbXVzdCBiZSBlcXVhbCB0byBbJyArIGxpbWl0Lm1hcChmdW5jdGlvbiAobCkge1xuICAgICAgICAgIHJldHVybiAnXCInICsgbCArICdcIic7XG4gICAgICAgIH0pLmpvaW4oJyBvciAnKSArICddLCBidXQgaXMgZXF1YWwgdG8gXCInICsgY2FuZGlkYXRlICsgJ1wiJywgbnVsbCwgJ2VxJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2FuZGlkYXRlICE9PSBsaW1pdCkge1xuICAgICAgICAgIHRoaXMucmVwb3J0KCdtdXN0IGJlIGVxdWFsIHRvIFwiJyArIGxpbWl0ICsgJ1wiLCBidXQgaXMgZXF1YWwgdG8gXCInICsgY2FuZGlkYXRlICsgJ1wiJywgbnVsbCwgJ2VxJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG5lOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FuZGlkYXRlICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgY2FuZGlkYXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbGltaXQgPSBzY2hlbWEubmU7XG4gICAgICBpZiAodHlwZW9mIGxpbWl0ICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgbGltaXQgIT09ICdzdHJpbmcnICYmICFfdHlwZUlzLmFycmF5KGxpbWl0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoX3R5cGVJcy5hcnJheShsaW1pdCkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW1pdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUgPT09IGxpbWl0W2ldKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydCgnbXVzdCBub3QgYmUgZXF1YWwgdG8gXCInICsgbGltaXRbaV0gKyAnXCInLCBudWxsLCAnbmUnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjYW5kaWRhdGUgPT09IGxpbWl0KSB7XG4gICAgICAgICAgdGhpcy5yZXBvcnQoJ211c3Qgbm90IGJlIGVxdWFsIHRvIFwiJyArIGxpbWl0ICsgJ1wiJywgbnVsbCwgJ25lJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG11bHRpcGxlT2Y6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSkge1xuICAgICAgY29uc3QgZGl2aXNvciA9IE51bWJlcihzY2hlbWEubXVsdGlwbGVPZik7XG4gICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZSAhPT0gJ251bWJlcicgfHwgaXNOYU4oZGl2aXNvcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNhbmRpZGF0ZSAlIGRpdmlzb3IgIT09IDApIHtcbiAgICAgICAgdGhpcy5yZXBvcnQoY2FuZGlkYXRlICsgJyBpcyBub3QgZGl2aXNpYmxlIGJ5ICcgKyBkaXZpc29yLCBudWxsLCAnbXVsdGlwbGVPZicpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc29tZUtleXM6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0KSB7XG4gICAgICB2YXIgX2tleXMgPSBzY2hlbWEuc29tZUtleXM7XG4gICAgICBpZiAoIV90eXBlSXMub2JqZWN0KGNhbmRpZGF0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdmFsaWQgPSBfa2V5cy5zb21lKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIChhY3Rpb24gaW4gY2FuZGlkYXQpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIHRoaXMucmVwb3J0KCdtdXN0IGhhdmUgYXQgbGVhc3Qga2V5ICcgKyBfa2V5cy5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gJ1wiJyArIGkgKyAnXCInO1xuICAgICAgICB9KS5qb2luKCcgb3IgJyksIG51bGwsICdzb21lS2V5cycpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3RyaWN0OiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLnN0cmljdCA9PT0gJ3N0cmluZycpIHsgc2NoZW1hLnN0cmljdCA9IChzY2hlbWEuc3RyaWN0ID09PSAndHJ1ZScpOyB9XG4gICAgICBpZiAoc2NoZW1hLnN0cmljdCAhPT0gdHJ1ZSB8fCAhX3R5cGVJcy5vYmplY3QoY2FuZGlkYXRlKSB8fCAhX3R5cGVJcy5vYmplY3Qoc2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLnByb3BlcnRpZXNbJyonXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGludHJ1ZGVyID0gT2JqZWN0LmtleXMoY2FuZGlkYXRlKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiAodHlwZW9mIHNjaGVtYS5wcm9wZXJ0aWVzW2tleV0gPT09ICd1bmRlZmluZWQnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbnRydWRlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIG1zZyA9ICdzaG91bGQgbm90IGNvbnRhaW5zICcgKyAoaW50cnVkZXIubGVuZ3RoID4gMSA/ICdwcm9wZXJ0aWVzJyA6ICdwcm9wZXJ0eScpICtcbiAgICAgICAgICAgICcgWycgKyBpbnRydWRlci5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuICdcIicgKyBpICsgJ1wiJzsgfSkuam9pbignLCAnKSArICddJztcbiAgICAgICAgICBzZWxmLnJlcG9ydChtc2csIG51bGwsICdzdHJpY3QnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZXhlYzogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jRXhlYyhzY2hlbWEsIGNhbmRpZGF0ZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgKF90eXBlSXMuYXJyYXkoc2NoZW1hLmV4ZWMpID8gc2NoZW1hLmV4ZWMgOiBbc2NoZW1hLmV4ZWNdKS5mb3JFYWNoKGZ1bmN0aW9uIChleGVjKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXhlYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGV4ZWMuY2FsbChzZWxmLCBzY2hlbWEsIGNhbmRpZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcHJvcGVydGllczogZnVuY3Rpb24gKHNjaGVtYSwgY2FuZGlkYXRlLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luY1Byb3BlcnRpZXMoc2NoZW1hLCBjYW5kaWRhdGUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHNjaGVtYS5wcm9wZXJ0aWVzIGluc3RhbmNlb2YgT2JqZWN0KSB8fCAhKGNhbmRpZGF0ZSBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BlcnRpZXMgPSBzY2hlbWEucHJvcGVydGllcztcbiAgICAgIHZhciBpO1xuICAgICAgaWYgKHByb3BlcnRpZXNbJyonXSAhPSBudWxsKSB7XG4gICAgICAgIGZvciAoaSBpbiBjYW5kaWRhdGUpIHtcbiAgICAgICAgICBpZiAoaSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZGVlcGVyT2JqZWN0KGkpO1xuICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlKHByb3BlcnRpZXNbJyonXSwgY2FuZGlkYXRlW2ldKTtcbiAgICAgICAgICB0aGlzLl9iYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoaSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChpID09PSAnKicpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZWVwZXJPYmplY3QoaSk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlKHByb3BlcnRpZXNbaV0sIGNhbmRpZGF0ZVtpXSk7XG4gICAgICAgIHRoaXMuX2JhY2soKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGl0ZW1zOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jSXRlbXMoc2NoZW1hLCBjYW5kaWRhdGUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHNjaGVtYS5pdGVtcyBpbnN0YW5jZW9mIE9iamVjdCkgfHwgIShjYW5kaWRhdGUgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVtcyA9IHNjaGVtYS5pdGVtcztcbiAgICAgIHZhciBpLCBsO1xuICAgICAgLy8gSWYgcHJvdmlkZWQgc2NoZW1hIGlzIGFuIGFycmF5XG4gICAgICAvLyB0aGVuIGNhbGwgdmFsaWRhdGUgZm9yIGVhY2ggY2FzZVxuICAgICAgLy8gZWxzZSBpdCBpcyBhbiBPYmplY3RcbiAgICAgIC8vIHRoZW4gY2FsbCB2YWxpZGF0ZSBmb3IgZWFjaCBrZXlcbiAgICAgIGlmIChfdHlwZUlzLmFycmF5KGl0ZW1zKSAmJiBfdHlwZUlzLmFycmF5KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuX2RlZXBlckFycmF5KGkpO1xuICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlKGl0ZW1zW2ldLCBjYW5kaWRhdGVbaV0pO1xuICAgICAgICAgIHRoaXMuX2JhY2soKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGNhbmRpZGF0ZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2FuZGlkYXRlLCBrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWVwZXJBcnJheShrZXkpO1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGUoaXRlbXMsIGNhbmRpZGF0ZVtrZXldKTtcbiAgICAgICAgICAgIHRoaXMuX2JhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIF9hc3luY1ZhbGlkYXRpb25BdHRyaWJ1dCA9IHtcbiAgICBhc3luY0V4ZWM6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGFzeW5jLmVhY2hTZXJpZXMoX3R5cGVJcy5hcnJheShzY2hlbWEuZXhlYykgPyBzY2hlbWEuZXhlYyA6IFtzY2hlbWEuZXhlY10sIGZ1bmN0aW9uIChleGVjLCBkb25lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXhlYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGlmIChleGVjLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBleGVjLmNhbGwoc2VsZiwgc2NoZW1hLCBjYW5kaWRhdGUsIGRvbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleGVjLmNhbGwoc2VsZiwgc2NoZW1hLCBjYW5kaWRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jLm5leHRUaWNrKGRvbmUpO1xuICAgICAgfSwgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgYXN5bmNQcm9wZXJ0aWVzOiBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIShzY2hlbWEucHJvcGVydGllcyBpbnN0YW5jZW9mIE9iamVjdCkgfHwgIV90eXBlSXMub2JqZWN0KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHNjaGVtYS5wcm9wZXJ0aWVzO1xuICAgICAgYXN5bmMuc2VyaWVzKFtcbiAgICAgICAgZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllc1snKiddID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoT2JqZWN0LmtleXMoY2FuZGlkYXRlKSwgZnVuY3Rpb24gKGksIGRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFzeW5jLm5leHRUaWNrKGRvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5fZGVlcGVyT2JqZWN0KGkpO1xuICAgICAgICAgICAgc2VsZi5fYXN5bmNWYWxpZGF0ZShwcm9wZXJ0aWVzWycqJ10sIGNhbmRpZGF0ZVtpXSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICBzZWxmLl9iYWNrKCk7XG4gICAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIG5leHQpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoT2JqZWN0LmtleXMocHJvcGVydGllcyksIGZ1bmN0aW9uIChpLCBkb25lKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhc3luYy5uZXh0VGljayhkb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuX2RlZXBlck9iamVjdChpKTtcbiAgICAgICAgICAgIHNlbGYuX2FzeW5jVmFsaWRhdGUocHJvcGVydGllc1tpXSwgY2FuZGlkYXRlW2ldLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIHNlbGYuX2JhY2soKTtcbiAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgIF0sIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIGFzeW5jSXRlbXM6IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghKHNjaGVtYS5pdGVtcyBpbnN0YW5jZW9mIE9iamVjdCkgfHwgIShjYW5kaWRhdGUgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGl0ZW1zID0gc2NoZW1hLml0ZW1zO1xuXG4gICAgICBpZiAoX3R5cGVJcy5hcnJheShpdGVtcykgJiYgX3R5cGVJcy5hcnJheShjYW5kaWRhdGUpKSB7XG4gICAgICAgIGFzeW5jLnRpbWVzU2VyaWVzKGl0ZW1zLmxlbmd0aCwgZnVuY3Rpb24gKGksIGRvbmUpIHtcbiAgICAgICAgICBzZWxmLl9kZWVwZXJBcnJheShpKTtcbiAgICAgICAgICBzZWxmLl9hc3luY1ZhbGlkYXRlKGl0ZW1zW2ldLCBjYW5kaWRhdGVbaV0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgc2VsZi5fYmFjaygpO1xuICAgICAgICAgICAgZG9uZShlcnIsIHJlcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5fYmFjaygpO1xuICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3luYy5lYWNoU2VyaWVzKE9iamVjdC5rZXlzKGNhbmRpZGF0ZSksIGZ1bmN0aW9uIChrZXksIGRvbmUpIHtcbiAgICAgICAgICBzZWxmLl9kZWVwZXJBcnJheShrZXkpO1xuICAgICAgICAgIHNlbGYuX2FzeW5jVmFsaWRhdGUoaXRlbXMsIGNhbmRpZGF0ZVtrZXldLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgIHNlbGYuX2JhY2soKTtcbiAgICAgICAgICAgIGRvbmUoZXJyLCByZXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFZhbGlkYXRpb24gQ2xhc3MgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBpbmhlcml0cyBmcm9tIEluc3BlY3Rpb24gY2xhc3MgKGFjdHVhbGx5IHdlIGp1c3QgY2FsbCBJbnNwZWN0aW9uXG4gIC8vIGNvbnN0cnVjdG9yIHdpdGggdGhlIG5ldyBjb250ZXh0LCBiZWNhdXNlIGl0cyBwcm90b3R5cGUgaXMgZW1wdHlcbiAgZnVuY3Rpb24gVmFsaWRhdGlvbihzY2hlbWEsIGN1c3RvbSkge1xuICAgIEluc3BlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgc2NoZW1hLCBfbWVyZ2UoVmFsaWRhdGlvbi5jdXN0b20sIGN1c3RvbSkpO1xuICAgIHZhciBfZXJyb3IgPSBbXTtcblxuICAgIHRoaXMuX2Jhc2ljRmllbGRzID0gT2JqZWN0LmtleXMoX3ZhbGlkYXRpb25BdHRyaWJ1dCk7XG4gICAgdGhpcy5fY3VzdG9tRmllbGRzID0gT2JqZWN0LmtleXModGhpcy5fY3VzdG9tKTtcbiAgICB0aGlzLm9yaWdpbiA9IG51bGw7XG5cbiAgICB0aGlzLnJlcG9ydCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBjb2RlLCByZWFzb24pIHtcbiAgICAgIHZhciBuZXdFcnIgPSB7XG4gICAgICAgIGNvZGU6IGNvZGUgfHwgdGhpcy51c2VyQ29kZSB8fCBudWxsLFxuICAgICAgICByZWFzb246IHJlYXNvbiB8fCAndW5rbm93bicsXG4gICAgICAgIG1lc3NhZ2U6IHRoaXMudXNlckVycm9yIHx8IG1lc3NhZ2UgfHwgJ2lzIGludmFsaWQnLFxuICAgICAgICBwcm9wZXJ0eTogdGhpcy51c2VyQWxpYXMgPyAodGhpcy51c2VyQWxpYXMgKyAnICgnICsgdGhpcy5fZHVtcFN0YWNrKCkgKyAnKScpIDogdGhpcy5fZHVtcFN0YWNrKClcbiAgICAgIH07XG4gICAgICBfZXJyb3IucHVzaChuZXdFcnIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHRoaXMucmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IF9lcnJvcixcbiAgICAgICAgdmFsaWQ6IF9lcnJvci5sZW5ndGggPT09IDAsXG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLnZhbGlkID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0NhbmRpZGF0ZSBpcyB2YWxpZCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuICdQcm9wZXJ0eSAnICsgaS5wcm9wZXJ0eSArICc6ICcgKyBpLm1lc3NhZ2U7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIF9leHRlbmQoVmFsaWRhdGlvbi5wcm90b3R5cGUsIF92YWxpZGF0aW9uQXR0cmlidXQpO1xuICBfZXh0ZW5kKFZhbGlkYXRpb24ucHJvdG90eXBlLCBfYXN5bmNWYWxpZGF0aW9uQXR0cmlidXQpO1xuICBfZXh0ZW5kKFZhbGlkYXRpb24sIG5ldyBDdXN0b21pc2FibGUoKSk7XG5cbiAgVmFsaWRhdGlvbi5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoY2FuZGlkYXRlLCBjYWxsYmFjaykge1xuICAgIHRoaXMub3JpZ2luID0gY2FuZGlkYXRlO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBhc3luYy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX2FzeW5jVmFsaWRhdGUoc2VsZi5fc2NoZW1hLCBjYW5kaWRhdGUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBzZWxmLm9yaWdpbiA9IG51bGw7XG4gICAgICAgICAgY2FsbGJhY2soZXJyLCBzZWxmLnJlc3VsdCgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlKHRoaXMuX3NjaGVtYSwgY2FuZGlkYXRlKS5yZXN1bHQoKTtcbiAgfTtcblxuICBWYWxpZGF0aW9uLnByb3RvdHlwZS5fdmFsaWRhdGUgPSBmdW5jdGlvbiAoc2NoZW1hLCBjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy51c2VyQ29kZSA9IHNjaGVtYS5jb2RlIHx8IG51bGw7XG4gICAgdGhpcy51c2VyRXJyb3IgPSBzY2hlbWEuZXJyb3IgfHwgbnVsbDtcbiAgICB0aGlzLnVzZXJBbGlhcyA9IHNjaGVtYS5hbGlhcyB8fCBudWxsO1xuICAgIHRoaXMuX2Jhc2ljRmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgIGlmICgoaSBpbiBzY2hlbWEgfHwgaSA9PT0gJ29wdGlvbmFsJykgJiYgdHlwZW9mIHRoaXNbaV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpc1tpXShzY2hlbWEsIGNhbmRpZGF0ZSk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fY3VzdG9tRmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgIGlmIChpIGluIHNjaGVtYSAmJiB0eXBlb2YgdGhpcy5fY3VzdG9tW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2N1c3RvbVtpXS5jYWxsKHRoaXMsIHNjaGVtYSwgY2FuZGlkYXRlKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBWYWxpZGF0aW9uLnByb3RvdHlwZS5fYXN5bmNWYWxpZGF0ZSA9IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy51c2VyQ29kZSA9IHNjaGVtYS5jb2RlIHx8IG51bGw7XG4gICAgdGhpcy51c2VyRXJyb3IgPSBzY2hlbWEuZXJyb3IgfHwgbnVsbDtcbiAgICB0aGlzLnVzZXJBbGlhcyA9IHNjaGVtYS5hbGlhcyB8fCBudWxsO1xuXG4gICAgYXN5bmMuc2VyaWVzKFtcbiAgICAgIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoT2JqZWN0LmtleXMoX3ZhbGlkYXRpb25BdHRyaWJ1dCksIGZ1bmN0aW9uIChpLCBkb25lKSB7XG4gICAgICAgICAgYXN5bmMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKChpIGluIHNjaGVtYSB8fCBpID09PSAnb3B0aW9uYWwnKSAmJiB0eXBlb2Ygc2VsZltpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBpZiAoc2VsZltpXS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGZbaV0oc2NoZW1hLCBjYW5kaWRhdGUsIGRvbmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGZbaV0oc2NoZW1hLCBjYW5kaWRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBuZXh0KTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICBhc3luYy5lYWNoU2VyaWVzKE9iamVjdC5rZXlzKHNlbGYuX2N1c3RvbSksIGZ1bmN0aW9uIChpLCBkb25lKSB7XG4gICAgICAgICAgYXN5bmMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2NoZW1hICYmIHR5cGVvZiBzZWxmLl9jdXN0b21baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGYuX2N1c3RvbVtpXS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2N1c3RvbVtpXS5jYWxsKHNlbGYsIHNjaGVtYSwgY2FuZGlkYXRlLCBkb25lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZWxmLl9jdXN0b21baV0uY2FsbChzZWxmLCBzY2hlbWEsIGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIG5leHQpO1xuICAgICAgfVxuICAgIF0sIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvLyBTYW5pdGl6YXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBmdW5jdGlvbnMgY2FsbGVkIGJ5IF9zYW5pdGl6YXRpb24udHlwZSBtZXRob2QuXG4gIHZhciBfZm9yY2VUeXBlID0ge1xuICAgIG51bWJlcjogZnVuY3Rpb24gKHBvc3QsIHNjaGVtYSkge1xuICAgICAgdmFyIG47XG4gICAgICBpZiAodHlwZW9mIHBvc3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfSBlbHNlIGlmIChwb3N0ID09PSAnJykge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5kZWYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVtYS5kZWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwb3N0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBuID0gcGFyc2VGbG9hdChwb3N0LnJlcGxhY2UoLywvZywgJy4nKS5yZXBsYWNlKC8gL2csICcnKSk7XG4gICAgICAgIGlmICh0eXBlb2YgbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwb3N0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gK3Bvc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGludGVnZXI6IGZ1bmN0aW9uIChwb3N0LCBzY2hlbWEpIHtcbiAgICAgIHZhciBuO1xuICAgICAgaWYgKHR5cGVvZiBwb3N0ID09PSAnbnVtYmVyJyAmJiBwb3N0ICUgMSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH0gZWxzZSBpZiAocG9zdCA9PT0gJycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuZGVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiBzY2hlbWEuZGVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcG9zdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbiA9IHBhcnNlSW50KHBvc3QucmVwbGFjZSgvIC9nLCAnJyksIDEwKTtcbiAgICAgICAgaWYgKHR5cGVvZiBuID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwb3N0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQocG9zdCwgMTApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcG9zdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGlmIChwb3N0KSB7IHJldHVybiAxOyB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIGlmIChwb3N0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gK3Bvc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHN0cmluZzogZnVuY3Rpb24gKHBvc3QsIHNjaGVtYSkge1xuICAgICAgaWYgKHR5cGVvZiBwb3N0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHBvc3QgPT09ICdudW1iZXInIHx8IHBvc3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBwb3N0LnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKF90eXBlSXMuYXJyYXkocG9zdCkpIHtcbiAgICAgICAgLy8gSWYgdXNlciBhdXRob3JpemUgYXJyYXkgYW5kIHN0cmluZ3MuLi5cbiAgICAgICAgaWYgKHNjaGVtYS5pdGVtcyB8fCBzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3N0LmpvaW4oU3RyaW5nKHNjaGVtYS5qb2luV2l0aCB8fCAnLCcpKTtcbiAgICAgIH0gZWxzZSBpZiAocG9zdCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAvLyBJZiB1c2VyIGF1dGhvcml6ZSBvYmplY3RzIGFucyBzdHJpbmdzLi4uXG4gICAgICAgIGlmIChzY2hlbWEuaXRlbXMgfHwgc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocG9zdCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwb3N0ID09PSAnc3RyaW5nJyAmJiBwb3N0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZGF0ZTogZnVuY3Rpb24gKHBvc3QsIHNjaGVtYSkge1xuICAgICAgaWYgKHBvc3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZShwb3N0KTtcbiAgICAgICAgaWYgKCFpc05hTihkLmdldFRpbWUoKSkpIHsgLy8gaWYgdmFsaWQgZGF0ZVxuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGJvb2xlYW46IGZ1bmN0aW9uIChwb3N0LCBzY2hlbWEpIHtcbiAgICAgIGlmICh0eXBlb2YgcG9zdCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBwb3N0ID09PSAnc3RyaW5nJyAmJiBwb3N0LnRvTG93ZXJDYXNlKCkgPT09ICdmYWxzZScpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiAhIXBvc3Q7XG4gICAgfSxcbiAgICBvYmplY3Q6IGZ1bmN0aW9uIChwb3N0LCBzY2hlbWEpIHtcbiAgICAgIGlmICh0eXBlb2YgcG9zdCAhPT0gJ3N0cmluZycgfHwgX3R5cGVJcy5vYmplY3QocG9zdCkpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShwb3N0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBhcnJheTogZnVuY3Rpb24gKHBvc3QsIHNjaGVtYSkge1xuICAgICAgaWYgKF90eXBlSXMuYXJyYXkocG9zdCkpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBvc3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwb3N0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAocG9zdC5zdWJzdHJpbmcoMCwgMSkgPT09ICdbJyAmJiBwb3N0LnNsaWNlKC0xKSA9PT0gJ10nKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHBvc3QpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zdC5zcGxpdChTdHJpbmcoc2NoZW1hLnNwbGl0V2l0aCB8fCAnLCcpKTtcbiAgICAgIH1cbiAgICAgIGlmICghX3R5cGVJcy5hcnJheShwb3N0KSkge1xuICAgICAgICByZXR1cm4gW3Bvc3RdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHZhciBfYXBwbHlSdWxlcyA9IHtcbiAgICB1cHBlcjogZnVuY3Rpb24gKHBvc3QpIHtcbiAgICAgIHJldHVybiBwb3N0LnRvVXBwZXJDYXNlKCk7XG4gICAgfSxcbiAgICBsb3dlcjogZnVuY3Rpb24gKHBvc3QpIHtcbiAgICAgIHJldHVybiBwb3N0LnRvTG93ZXJDYXNlKCk7XG4gICAgfSxcbiAgICB0aXRsZTogZnVuY3Rpb24gKHBvc3QpIHtcbiAgICAgIC8vIEZpeCBieSBzZWIgKHJlcGxhY2UgXFx3XFxTKiBieSBcXFMqID0+IGV4ZW1wbGUgOiBjb3Vjb3Ugw6dhIHZhKVxuICAgICAgcmV0dXJuIHBvc3QucmVwbGFjZSgvXFxTKi9nLCBmdW5jdGlvbiAodHh0KSB7XG4gICAgICAgIHJldHVybiB0eHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eHQuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNhcGl0YWxpemU6IGZ1bmN0aW9uIChwb3N0KSB7XG4gICAgICByZXR1cm4gcG9zdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHBvc3Quc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgfSxcbiAgICB1Y2ZpcnN0OiBmdW5jdGlvbiAocG9zdCkge1xuICAgICAgcmV0dXJuIHBvc3QuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwb3N0LnN1YnN0cigxKTtcbiAgICB9LFxuICAgIHRyaW06IGZ1bmN0aW9uIChwb3N0KSB7XG4gICAgICByZXR1cm4gcG9zdC50cmltKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEV2ZXJ5IGZ1bmN0aW9uIHJldHVybiB0aGUgZnV0dXJlIHZhbHVlIG9mIGVhY2ggcHJvcGVydHkuIFRoZXJlZm9yZSB5b3VcbiAgLy8gaGF2ZSB0byByZXR1cm4gcG9zdCBldmVuIGlmIHlvdSBkbyBub3QgY2hhbmdlIGl0cyB2YWx1ZVxuICB2YXIgX3Nhbml0aXphdGlvbkF0dHJpYnV0ID0ge1xuICAgIHN0cmljdDogZnVuY3Rpb24gKHNjaGVtYSwgcG9zdCkge1xuICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuc3RyaWN0ID09PSAnc3RyaW5nJykgeyBzY2hlbWEuc3RyaWN0ID0gKHNjaGVtYS5zdHJpY3QgPT09ICd0cnVlJyk7IH1cbiAgICAgIGlmIChzY2hlbWEuc3RyaWN0ICE9PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgaWYgKCFfdHlwZUlzLm9iamVjdChzY2hlbWEucHJvcGVydGllcykpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICBpZiAoIV90eXBlSXMub2JqZWN0KHBvc3QpKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXMocG9zdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBzY2hlbWEucHJvcGVydGllcykpIHtcbiAgICAgICAgICBkZWxldGUgcG9zdFtrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwb3N0O1xuICAgIH0sXG4gICAgb3B0aW9uYWw6IGZ1bmN0aW9uIChzY2hlbWEsIHBvc3QpIHtcbiAgICAgIHZhciBvcHQgPSB0eXBlb2Ygc2NoZW1hLm9wdGlvbmFsID09PSAnYm9vbGVhbicgPyBzY2hlbWEub3B0aW9uYWwgOiAoc2NoZW1hLm9wdGlvbmFsICE9PSAnZmFsc2UnKTsgLy8gRGVmYXVsdDogdHJ1ZVxuICAgICAgaWYgKG9wdCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcG9zdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICB0aGlzLnJlcG9ydCgpO1xuICAgICAgaWYgKHNjaGVtYS5kZWYgPT09IERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hLmRlZjtcbiAgICB9LFxuICAgIHR5cGU6IGZ1bmN0aW9uIChzY2hlbWEsIHBvc3QpIHtcbiAgICAgIC8vIGlmIChfdHlwZUlzWydvYmplY3QnXShwb3N0KSB8fCBfdHlwZUlzLmFycmF5KHBvc3QpKSB7XG4gICAgICAvLyAgIHJldHVybiBwb3N0O1xuICAgICAgLy8gfVxuICAgICAgaWYgKHR5cGVvZiBzY2hlbWEudHlwZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIF9mb3JjZVR5cGVbc2NoZW1hLnR5cGVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgdmFyIG47XG4gICAgICB2YXIgb3B0ID0gdHlwZW9mIHNjaGVtYS5vcHRpb25hbCA9PT0gJ2Jvb2xlYW4nID8gc2NoZW1hLm9wdGlvbmFsIDogdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2YgX2ZvcmNlVHlwZVtzY2hlbWEudHlwZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbiA9IF9mb3JjZVR5cGVbc2NoZW1hLnR5cGVdKHBvc3QsIHNjaGVtYSk7XG4gICAgICAgIGlmICgobiA9PT0gbnVsbCAmJiAhb3B0KSB8fCAoIW4gJiYgaXNOYU4obikpIHx8IChuID09PSBudWxsICYmIHNjaGVtYS50eXBlID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICBuID0gc2NoZW1hLmRlZjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghb3B0KSB7XG4gICAgICAgIG4gPSBzY2hlbWEuZGVmO1xuICAgICAgfVxuICAgICAgaWYgKChuICE9IG51bGwgfHwgKHR5cGVvZiBzY2hlbWEuZGVmICE9PSAndW5kZWZpbmVkJyAmJiBzY2hlbWEuZGVmID09PSBuKSkgJiYgbiAhPT0gcG9zdCkge1xuICAgICAgICB0aGlzLnJlcG9ydCgpO1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3N0O1xuICAgIH0sXG4gICAgcnVsZXM6IGZ1bmN0aW9uIChzY2hlbWEsIHBvc3QpIHtcbiAgICAgIHZhciBydWxlcyA9IHNjaGVtYS5ydWxlcztcbiAgICAgIGlmICh0eXBlb2YgcG9zdCAhPT0gJ3N0cmluZycgfHwgKHR5cGVvZiBydWxlcyAhPT0gJ3N0cmluZycgJiYgIV90eXBlSXMuYXJyYXkocnVsZXMpKSkge1xuICAgICAgICByZXR1cm4gcG9zdDtcbiAgICAgIH1cbiAgICAgIHZhciBtb2RpZmllZCA9IGZhbHNlO1xuICAgICAgKF90eXBlSXMuYXJyYXkocnVsZXMpID8gcnVsZXMgOiBbcnVsZXNdKS5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgX2FwcGx5UnVsZXNbcnVsZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBwb3N0ID0gX2FwcGx5UnVsZXNbcnVsZV0ocG9zdCk7XG4gICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgICB0aGlzLnJlcG9ydCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfSxcbiAgICBtaW46IGZ1bmN0aW9uIChzY2hlbWEsIHBvc3QpIHtcbiAgICAgIHZhciBwb3N0VGVzdCA9IE51bWJlcihwb3N0KTtcbiAgICAgIGlmIChpc05hTihwb3N0VGVzdCkpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICB2YXIgbWluID0gTnVtYmVyKHNjaGVtYS5taW4pO1xuICAgICAgaWYgKGlzTmFOKG1pbikpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICBpZiAocG9zdFRlc3QgPCBtaW4pIHtcbiAgICAgICAgdGhpcy5yZXBvcnQoKTtcbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3N0O1xuICAgIH0sXG4gICAgbWF4OiBmdW5jdGlvbiAoc2NoZW1hLCBwb3N0KSB7XG4gICAgICB2YXIgcG9zdFRlc3QgPSBOdW1iZXIocG9zdCk7XG4gICAgICBpZiAoaXNOYU4ocG9zdFRlc3QpKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgdmFyIG1heCA9IE51bWJlcihzY2hlbWEubWF4KTtcbiAgICAgIGlmIChpc05hTihtYXgpKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgaWYgKHBvc3RUZXN0ID4gbWF4KSB7XG4gICAgICAgIHRoaXMucmVwb3J0KCk7XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zdDtcbiAgICB9LFxuICAgIG1pbkxlbmd0aDogZnVuY3Rpb24gKHNjaGVtYSwgcG9zdCkge1xuICAgICAgdmFyIGxpbWl0ID0gTnVtYmVyKHNjaGVtYS5taW5MZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBwb3N0ICE9PSAnc3RyaW5nJyB8fCBpc05hTihsaW1pdCkgfHwgbGltaXQgPCAwKSB7XG4gICAgICAgIHJldHVybiBwb3N0O1xuICAgICAgfVxuICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgdmFyIGdhcCA9IGxpbWl0IC0gcG9zdC5sZW5ndGg7XG4gICAgICBpZiAoZ2FwID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdhcDsgaSsrKSB7XG4gICAgICAgICAgc3RyICs9ICctJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcG9ydCgpO1xuICAgICAgICByZXR1cm4gcG9zdCArIHN0cjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3N0O1xuICAgIH0sXG4gICAgbWF4TGVuZ3RoOiBmdW5jdGlvbiAoc2NoZW1hLCBwb3N0KSB7XG4gICAgICB2YXIgbGltaXQgPSBOdW1iZXIoc2NoZW1hLm1heExlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIHBvc3QgIT09ICdzdHJpbmcnIHx8IGlzTmFOKGxpbWl0KSB8fCBsaW1pdCA8IDApIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICBpZiAocG9zdC5sZW5ndGggPiBsaW1pdCkge1xuICAgICAgICB0aGlzLnJlcG9ydCgpO1xuICAgICAgICByZXR1cm4gcG9zdC5zbGljZSgwLCBsaW1pdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zdDtcbiAgICB9LFxuICAgIHByb3BlcnRpZXM6IGZ1bmN0aW9uIChzY2hlbWEsIHBvc3QsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jUHJvcGVydGllcyhzY2hlbWEsIHBvc3QsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghcG9zdCB8fCB0eXBlb2YgcG9zdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHNjaGVtYS5wcm9wZXJ0aWVzO1xuICAgICAgdmFyIHRtcDtcbiAgICAgIHZhciBpO1xuICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzWycqJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZvciAoaSBpbiBwb3N0KSB7XG4gICAgICAgICAgaWYgKGkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2RlZXBlck9iamVjdChpKTtcbiAgICAgICAgICB0bXAgPSB0aGlzLl9zYW5pdGl6ZShwcm9wZXJ0aWVzWycqJ10sIHBvc3RbaV0pO1xuICAgICAgICAgIGlmICh0eXBlb2YgdG1wICE9PSAndW5kZWZpbmVkJyB8fCAnZXhlYycgaW4gcHJvcGVydGllc1snKiddKSB7XG4gICAgICAgICAgICBwb3N0W2ldID0gdG1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9iYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoaSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChpICE9PSAnKicpIHtcbiAgICAgICAgICB0aGlzLl9kZWVwZXJPYmplY3QoaSk7XG4gICAgICAgICAgdG1wID0gdGhpcy5fc2FuaXRpemUocHJvcGVydGllc1tpXSwgcG9zdFtpXSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0bXAgIT09ICd1bmRlZmluZWQnIHx8ICdleGVjJyBpbiBwcm9wZXJ0aWVzW2ldKSB7XG4gICAgICAgICAgICBwb3N0W2ldID0gdG1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9iYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3N0O1xuICAgIH0sXG4gICAgaXRlbXM6IGZ1bmN0aW9uIChzY2hlbWEsIHBvc3QsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jSXRlbXMoc2NoZW1hLCBwb3N0LCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShzY2hlbWEuaXRlbXMgaW5zdGFuY2VvZiBPYmplY3QpIHx8ICEocG9zdCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgICB9XG4gICAgICB2YXIgaTtcbiAgICAgIGlmIChfdHlwZUlzLmFycmF5KHNjaGVtYS5pdGVtcykgJiYgX3R5cGVJcy5hcnJheShwb3N0KSkge1xuICAgICAgICB2YXIgbWluTGVuZ3RoID0gc2NoZW1hLml0ZW1zLmxlbmd0aCA8IHBvc3QubGVuZ3RoID8gc2NoZW1hLml0ZW1zLmxlbmd0aCA6IHBvc3QubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWluTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9kZWVwZXJBcnJheShpKTtcbiAgICAgICAgICBwb3N0W2ldID0gdGhpcy5fc2FuaXRpemUoc2NoZW1hLml0ZW1zW2ldLCBwb3N0W2ldKTtcbiAgICAgICAgICB0aGlzLl9iYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSBpbiBwb3N0KSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwb3N0LCBpKSkge1xuICAgICAgICAgICAgdGhpcy5fZGVlcGVyQXJyYXkoaSk7XG4gICAgICAgICAgICBwb3N0W2ldID0gdGhpcy5fc2FuaXRpemUoc2NoZW1hLml0ZW1zLCBwb3N0W2ldKTtcbiAgICAgICAgICAgIHRoaXMuX2JhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3N0O1xuICAgIH0sXG4gICAgZXhlYzogZnVuY3Rpb24gKHNjaGVtYSwgcG9zdCwgY2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmNFeGVjKHNjaGVtYSwgcG9zdCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgdmFyIGV4ZWNzID0gX3R5cGVJcy5hcnJheShzY2hlbWEuZXhlYykgPyBzY2hlbWEuZXhlYyA6IFtzY2hlbWEuZXhlY107XG5cbiAgICAgIGV4ZWNzLmZvckVhY2goZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBleGVjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcG9zdCA9IGV4ZWMuY2FsbCh0aGlzLCBzY2hlbWEsIHBvc3QpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHJldHVybiBwb3N0O1xuICAgIH1cbiAgfTtcblxuICB2YXIgX2FzeW5jU2FuaXRpemF0aW9uQXR0cmlidXQgPSB7XG4gICAgYXN5bmNFeGVjOiBmdW5jdGlvbiAoc2NoZW1hLCBwb3N0LCBjYWxsYmFjaykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGV4ZWNzID0gX3R5cGVJcy5hcnJheShzY2hlbWEuZXhlYykgPyBzY2hlbWEuZXhlYyA6IFtzY2hlbWEuZXhlY107XG5cbiAgICAgIGFzeW5jLmVhY2hTZXJpZXMoZXhlY3MsIGZ1bmN0aW9uIChleGVjLCBkb25lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXhlYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGlmIChleGVjLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBleGVjLmNhbGwoc2VsZiwgc2NoZW1hLCBwb3N0LCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcG9zdCA9IHJlcztcbiAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvc3QgPSBleGVjLmNhbGwoc2VsZiwgc2NoZW1hLCBwb3N0KTtcbiAgICAgICAgfVxuICAgICAgICBkb25lKCk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcG9zdCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGFzeW5jUHJvcGVydGllczogZnVuY3Rpb24gKHNjaGVtYSwgcG9zdCwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghcG9zdCB8fCB0eXBlb2YgcG9zdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHBvc3QpO1xuICAgICAgfVxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBzY2hlbWEucHJvcGVydGllcztcblxuICAgICAgYXN5bmMuc2VyaWVzKFtcbiAgICAgICAgZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllc1snKiddID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBnbG9iaW5nID0gcHJvcGVydGllc1snKiddO1xuICAgICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoT2JqZWN0LmtleXMocG9zdCksIGZ1bmN0aW9uIChpLCBuZXh0KSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9kZWVwZXJPYmplY3QoaSk7XG4gICAgICAgICAgICBzZWxmLl9hc3luY1Nhbml0aXplKGdsb2JpbmcsIHBvc3RbaV0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7IC8qIEVycm9yIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBoZXJlICovIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcG9zdFtpXSA9IHJlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZWxmLl9iYWNrKCk7XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIG5leHQpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoT2JqZWN0LmtleXMocHJvcGVydGllcyksIGZ1bmN0aW9uIChpLCBuZXh0KSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9kZWVwZXJPYmplY3QoaSk7XG4gICAgICAgICAgICBzZWxmLl9hc3luY1Nhbml0aXplKHByb3BlcnRpZXNbaV0sIHBvc3RbaV0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwb3N0W2ldID0gcmVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGYuX2JhY2soKTtcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgIF0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgcG9zdCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGFzeW5jSXRlbXM6IGZ1bmN0aW9uIChzY2hlbWEsIHBvc3QsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIShzY2hlbWEuaXRlbXMgaW5zdGFuY2VvZiBPYmplY3QpIHx8ICEocG9zdCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHBvc3QpO1xuICAgICAgfVxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGl0ZW1zID0gc2NoZW1hLml0ZW1zO1xuICAgICAgaWYgKF90eXBlSXMuYXJyYXkoaXRlbXMpICYmIF90eXBlSXMuYXJyYXkocG9zdCkpIHtcbiAgICAgICAgdmFyIG1pbkxlbmd0aCA9IGl0ZW1zLmxlbmd0aCA8IHBvc3QubGVuZ3RoID8gaXRlbXMubGVuZ3RoIDogcG9zdC5sZW5ndGg7XG4gICAgICAgIGFzeW5jLnRpbWVzU2VyaWVzKG1pbkxlbmd0aCwgZnVuY3Rpb24gKGksIG5leHQpIHtcbiAgICAgICAgICBzZWxmLl9kZWVwZXJBcnJheShpKTtcbiAgICAgICAgICBzZWxmLl9hc3luY1Nhbml0aXplKGl0ZW1zW2ldLCBwb3N0W2ldLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc3RbaV0gPSByZXM7XG4gICAgICAgICAgICBzZWxmLl9iYWNrKCk7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIsIHBvc3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoT2JqZWN0LmtleXMocG9zdCksIGZ1bmN0aW9uIChrZXksIG5leHQpIHtcbiAgICAgICAgICBzZWxmLl9kZWVwZXJBcnJheShrZXkpO1xuICAgICAgICAgIHNlbGYuX2FzeW5jU2FuaXRpemUoaXRlbXMsIHBvc3Rba2V5XSwgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3N0W2tleV0gPSByZXM7XG4gICAgICAgICAgICBzZWxmLl9iYWNrKCk7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIsIHBvc3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3N0O1xuICAgIH1cbiAgfTtcblxuICAvLyBTYW5pdGl6YXRpb24gQ2xhc3MgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gaW5oZXJpdHMgZnJvbSBJbnNwZWN0aW9uIGNsYXNzIChhY3R1YWxseSB3ZSBqdXN0IGNhbGwgSW5zcGVjdGlvblxuICAvLyBjb25zdHJ1Y3RvciB3aXRoIHRoZSBuZXcgY29udGV4dCwgYmVjYXVzZSBpdHMgcHJvdG90eXBlIGlzIGVtcHR5XG4gIGZ1bmN0aW9uIFNhbml0aXphdGlvbihzY2hlbWEsIGN1c3RvbSkge1xuICAgIEluc3BlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgc2NoZW1hLCBfbWVyZ2UoU2FuaXRpemF0aW9uLmN1c3RvbSwgY3VzdG9tKSk7XG4gICAgdmFyIF9yZXBvcnRpbmcgPSBbXTtcblxuICAgIHRoaXMuX2Jhc2ljRmllbGRzID0gT2JqZWN0LmtleXMoX3Nhbml0aXphdGlvbkF0dHJpYnV0KTtcbiAgICB0aGlzLl9jdXN0b21GaWVsZHMgPSBPYmplY3Qua2V5cyh0aGlzLl9jdXN0b20pO1xuICAgIHRoaXMub3JpZ2luID0gbnVsbDtcblxuICAgIHRoaXMucmVwb3J0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHZhciBuZXdOb3QgPSB7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UgfHwgJ3dhcyBzYW5pdGl6ZWQnLFxuICAgICAgICBwcm9wZXJ0eTogdGhpcy51c2VyQWxpYXMgPyAodGhpcy51c2VyQWxpYXMgKyAnICgnICsgdGhpcy5fZHVtcFN0YWNrKCkgKyAnKScpIDogdGhpcy5fZHVtcFN0YWNrKClcbiAgICAgIH07XG4gICAgICBpZiAoIV9yZXBvcnRpbmcuc29tZShmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5wcm9wZXJ0eSA9PT0gbmV3Tm90LnByb3BlcnR5OyB9KSkge1xuICAgICAgICBfcmVwb3J0aW5nLnB1c2gobmV3Tm90KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5yZXN1bHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgLy8gRm9yIG9sZCBJRS5cbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG9iamVjdC1zaG9ydGhhbmQgKi9cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHJlcG9ydGluZzogX3JlcG9ydGluZyxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVwb3J0aW5nLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuICdQcm9wZXJ0eSAnICsgaS5wcm9wZXJ0eSArICcgJyArIGkubWVzc2FnZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgb2JqZWN0LXNob3J0aGFuZCAqL1xuICAgIH07XG4gIH1cblxuICBfZXh0ZW5kKFNhbml0aXphdGlvbi5wcm90b3R5cGUsIF9zYW5pdGl6YXRpb25BdHRyaWJ1dCk7XG4gIF9leHRlbmQoU2FuaXRpemF0aW9uLnByb3RvdHlwZSwgX2FzeW5jU2FuaXRpemF0aW9uQXR0cmlidXQpO1xuICBfZXh0ZW5kKFNhbml0aXphdGlvbiwgbmV3IEN1c3RvbWlzYWJsZSgpKTtcblxuICBTYW5pdGl6YXRpb24ucHJvdG90eXBlLnNhbml0aXplID0gZnVuY3Rpb24gKHBvc3QsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5vcmlnaW4gPSBwb3N0O1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9hc3luY1Nhbml0aXplKHRoaXMuX3NjaGVtYSwgcG9zdCwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICBzZWxmLm9yaWdpbiA9IG51bGw7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgc2VsZi5yZXN1bHQoZGF0YSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy5fc2FuaXRpemUodGhpcy5fc2NoZW1hLCBwb3N0KTtcbiAgICB0aGlzLm9yaWdpbiA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0KGRhdGEpO1xuICB9O1xuXG4gIFNhbml0aXphdGlvbi5wcm90b3R5cGUuX3Nhbml0aXplID0gZnVuY3Rpb24gKHNjaGVtYSwgcG9zdCkge1xuICAgIHRoaXMudXNlckFsaWFzID0gc2NoZW1hLmFsaWFzIHx8IG51bGw7XG4gICAgdGhpcy5fYmFzaWNGaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgaWYgKChpIGluIHNjaGVtYSB8fCBpID09PSAnb3B0aW9uYWwnKSAmJiB0eXBlb2YgdGhpc1tpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3N0ID0gdGhpc1tpXShzY2hlbWEsIHBvc3QpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX2N1c3RvbUZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICBpZiAoaSBpbiBzY2hlbWEgJiYgdHlwZW9mIHRoaXMuX2N1c3RvbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3N0ID0gdGhpcy5fY3VzdG9tW2ldLmNhbGwodGhpcywgc2NoZW1hLCBwb3N0KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gcG9zdDtcbiAgfTtcblxuICBTYW5pdGl6YXRpb24ucHJvdG90eXBlLl9hc3luY1Nhbml0aXplID0gZnVuY3Rpb24gKHNjaGVtYSwgcG9zdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy51c2VyQWxpYXMgPSBzY2hlbWEuYWxpYXMgfHwgbnVsbDtcblxuICAgIGFzeW5jLndhdGVyZmFsbChbXG4gICAgICBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICBhc3luYy5yZWR1Y2Uoc2VsZi5fYmFzaWNGaWVsZHMsIHBvc3QsIGZ1bmN0aW9uICh2YWx1ZSwgaSwgbmV4dCkge1xuICAgICAgICAgIGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICgoaSBpbiBzY2hlbWEgfHwgaSA9PT0gJ29wdGlvbmFsJykgJiYgdHlwZW9mIHNlbGZbaV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGZbaV0ubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmW2ldKHNjaGVtYSwgdmFsdWUsIG5leHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gc2VsZltpXShzY2hlbWEsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQobnVsbCwgdmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBuZXh0KTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAoaW50ZXIsIG5leHQpIHtcbiAgICAgICAgYXN5bmMucmVkdWNlKHNlbGYuX2N1c3RvbUZpZWxkcywgaW50ZXIsIGZ1bmN0aW9uICh2YWx1ZSwgaSwgbmV4dCkge1xuICAgICAgICAgIGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNjaGVtYSAmJiB0eXBlb2Ygc2VsZi5fY3VzdG9tW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGlmIChzZWxmLl9jdXN0b21baV0ubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9jdXN0b21baV0uY2FsbChzZWxmLCBzY2hlbWEsIHZhbHVlLCBuZXh0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHNlbGYuX2N1c3RvbVtpXS5jYWxsKHNlbGYsIHNjaGVtYSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dChudWxsLCB2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIG5leHQpO1xuICAgICAgfVxuICAgIF0sIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgSU5UX01JTiA9IC0yMTQ3NDgzNjQ4O1xuICB2YXIgSU5UX01BWCA9IDIxNDc0ODM2NDc7XG5cbiAgdmFyIF9yYW5kID0ge1xuICAgIGludDogZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gbWluICsgKDAgfCBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgICB9LFxuICAgIGZsb2F0OiBmdW5jdGlvbiAobWluLCBtYXgpIHtcbiAgICAgIHJldHVybiAoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluKTtcbiAgICB9LFxuICAgIGJvb2w6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoTWF0aC5yYW5kb20oKSA+IDAuNSk7XG4gICAgfSxcbiAgICBjaGFyOiBmdW5jdGlvbiAobWluLCBtYXgpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuaW50KG1pbiwgbWF4KSk7XG4gICAgfSxcbiAgICBmcm9tTGlzdDogZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgIHJldHVybiBsaXN0W3RoaXMuaW50KDAsIGxpc3QubGVuZ3RoIC0gMSldO1xuICAgIH1cbiAgfTtcblxuICB2YXIgX2Zvcm1hdFNhbXBsZSA9IHtcbiAgICAnZGF0ZS10aW1lJzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICB9LFxuICAgIGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvVC4qJC8sICcnKTtcbiAgICB9LFxuICAgIHRpbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZyh7fSwgeyBob3VyMTI6IGZhbHNlIH0pO1xuICAgIH0sXG4gICAgY29sb3I6IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgdmFyIHMgPSAnIyc7XG4gICAgICBpZiAobWluIDwgMSkge1xuICAgICAgICBtaW4gPSAxO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBfcmFuZC5pbnQobWluLCBtYXgpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHMgKz0gX3JhbmQuZnJvbUxpc3QoJzAxMjM0NTY3ODlhYmNkZWZBQkNERUYnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzO1xuICAgIH0sXG4gICAgbnVtZXJpYzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICcnICsgX3JhbmQuaW50KDAsIElOVF9NQVgpO1xuICAgIH0sXG4gICAgaW50ZWdlcjogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF9yYW5kLmJvb2woKSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gJy0nICsgdGhpcy5udW1lcmljKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5udW1lcmljKCk7XG4gICAgfSxcbiAgICBkZWNpbWFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnRlZ2VyKCkgKyAnLicgKyB0aGlzLm51bWVyaWMoKTtcbiAgICB9LFxuICAgIGFscGhhOiBmdW5jdGlvbiAobWluLCBtYXgpIHtcbiAgICAgIHZhciBzID0gJyc7XG4gICAgICBpZiAobWluIDwgMSkge1xuICAgICAgICBtaW4gPSAxO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBfcmFuZC5pbnQobWluLCBtYXgpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHMgKz0gX3JhbmQuZnJvbUxpc3QoJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzO1xuICAgIH0sXG4gICAgYWxwaGFOdW1lcmljOiBmdW5jdGlvbiAobWluLCBtYXgpIHtcbiAgICAgIHZhciBzID0gJyc7XG4gICAgICBpZiAobWluIDwgMSkge1xuICAgICAgICBtaW4gPSAxO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBfcmFuZC5pbnQobWluLCBtYXgpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHMgKz0gX3JhbmQuZnJvbUxpc3QoJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICB9LFxuICAgIGFscGhhRGFzaDogZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgICB2YXIgcyA9ICcnO1xuICAgICAgaWYgKG1pbiA8IDEpIHtcbiAgICAgICAgbWluID0gMTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gX3JhbmQuaW50KG1pbiwgbWF4KTsgaSA8IGw7IGkrKykge1xuICAgICAgICBzICs9IF9yYW5kLmZyb21MaXN0KCdfLWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6Xy1BQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWl8tMDEyMzQ1Njc4OV8tJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICB9LFxuICAgIGphdmFzY3JpcHQ6IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgdmFyIHMgPSBfcmFuZC5mcm9tTGlzdCgnXyRhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5el8kQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfJCcpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBfcmFuZC5pbnQobWluLCBtYXggLSAxKTsgaSA8IGw7IGkrKykge1xuICAgICAgICBzICs9IF9yYW5kLmZyb21MaXN0KCdfJGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XyRBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWl8kMDEyMzQ1Njc4OV8kJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gX2dldExpbWl0cyhzY2hlbWEpIHtcbiAgICB2YXIgbWluID0gSU5UX01JTjtcbiAgICB2YXIgbWF4ID0gSU5UX01BWDtcblxuICAgIGlmIChzY2hlbWEuZ3RlICE9IG51bGwpIHtcbiAgICAgIG1pbiA9IHNjaGVtYS5ndGU7XG4gICAgfSBlbHNlIGlmIChzY2hlbWEuZ3QgIT0gbnVsbCkge1xuICAgICAgbWluID0gc2NoZW1hLmd0ICsgMTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS5sdGUgIT0gbnVsbCkge1xuICAgICAgbWF4ID0gc2NoZW1hLmx0ZTtcbiAgICB9IGVsc2UgaWYgKHNjaGVtYS5sdCAhPSBudWxsKSB7XG4gICAgICBtYXggPSBzY2hlbWEubHQgLSAxO1xuICAgIH1cbiAgICAvLyBGb3Igb2xkIElFLlxuICAgIC8qIGVzbGludC1kaXNhYmxlIG9iamVjdC1zaG9ydGhhbmQgKi9cbiAgICByZXR1cm4geyBtaW46IG1pbiwgbWF4OiBtYXggfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG9iamVjdC1zaG9ydGhhbmQgKi9cbiAgfVxuXG4gIHZhciBfdHlwZUdlbmVyYXRvciA9IHtcbiAgICBzdHJpbmc6IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgIGlmIChzY2hlbWEuZXEgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmVxO1xuICAgICAgfVxuICAgICAgdmFyIHMgPSAnJztcbiAgICAgIHZhciBtaW5MZW5ndGggPSBzY2hlbWEubWluTGVuZ3RoICE9IG51bGwgPyBzY2hlbWEubWluTGVuZ3RoIDogMDtcbiAgICAgIHZhciBtYXhMZW5ndGggPSBzY2hlbWEubWF4TGVuZ3RoICE9IG51bGwgPyBzY2hlbWEubWF4TGVuZ3RoIDogMzI7XG4gICAgICBpZiAodHlwZW9mIHNjaGVtYS5wYXR0ZXJuID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgX2Zvcm1hdFNhbXBsZVtzY2hlbWEucGF0dGVybl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIF9mb3JtYXRTYW1wbGVbc2NoZW1hLnBhdHRlcm5dKG1pbkxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGwgPSBzY2hlbWEuZXhhY3RMZW5ndGggIT0gbnVsbCA/IHNjaGVtYS5leGFjdExlbmd0aCA6IF9yYW5kLmludChtaW5MZW5ndGgsIG1heExlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICBzICs9IF9yYW5kLmNoYXIoMzIsIDEyNik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICB9LFxuICAgIG51bWJlcjogZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgaWYgKHNjaGVtYS5lcSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuZXE7XG4gICAgICB9XG4gICAgICB2YXIgbGltaXQgPSBfZ2V0TGltaXRzKHNjaGVtYSk7XG4gICAgICB2YXIgbiA9IF9yYW5kLmZsb2F0KGxpbWl0Lm1pbiwgbGltaXQubWF4KTtcbiAgICAgIGlmIChzY2hlbWEubmUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbmUgPSBfdHlwZUlzLmFycmF5KHNjaGVtYS5uZSkgPyBzY2hlbWEubmUgOiBbc2NoZW1hLm5lXTtcbiAgICAgICAgd2hpbGUgKG5lLmluZGV4T2YobikgIT09IC0xKSB7XG4gICAgICAgICAgbiA9IF9yYW5kLmZsb2F0KGxpbWl0Lm1pbiwgbGltaXQubWF4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfSxcbiAgICBpbnRlZ2VyOiBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICBpZiAoc2NoZW1hLmVxICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5lcTtcbiAgICAgIH1cbiAgICAgIHZhciBsaW1pdCA9IF9nZXRMaW1pdHMoc2NoZW1hKTtcbiAgICAgIHZhciBuID0gX3JhbmQuaW50KGxpbWl0Lm1pbiwgbGltaXQubWF4KTtcbiAgICAgIGlmIChzY2hlbWEubmUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbmUgPSBfdHlwZUlzLmFycmF5KHNjaGVtYS5uZSkgPyBzY2hlbWEubmUgOiBbc2NoZW1hLm5lXTtcbiAgICAgICAgd2hpbGUgKG5lLmluZGV4T2YobikgIT09IC0xKSB7XG4gICAgICAgICAgbiA9IF9yYW5kLmludChsaW1pdC5taW4sIGxpbWl0Lm1heCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuO1xuICAgIH0sXG4gICAgYm9vbGVhbjogZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgaWYgKHNjaGVtYS5lcSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuZXE7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3JhbmQuYm9vbCgpO1xuICAgIH0sXG4gICAgbnVsbDogZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBkYXRlOiBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICBpZiAoc2NoZW1hLmVxICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5lcTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICAgIH0sXG4gICAgb2JqZWN0OiBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICB2YXIgbyA9IHt9O1xuICAgICAgdmFyIHByb3AgPSBzY2hlbWEucHJvcGVydGllcyB8fCB7fTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3ApIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wLCBrZXkpKSB7XG4gICAgICAgICAgaWYgKHByb3Bba2V5XS5vcHRpb25hbCA9PT0gdHJ1ZSAmJiBfcmFuZC5ib29sKCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoa2V5ICE9PSAnKicpIHtcbiAgICAgICAgICAgIG9ba2V5XSA9IHRoaXMuZ2VuZXJhdGUocHJvcFtrZXldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJrID0gJ19fcmFuZG9tX2tleV8nO1xuICAgICAgICAgICAgdmFyIHJhbmRvbUtleSA9IHJrICsgMDtcbiAgICAgICAgICAgIHZhciBuID0gX3JhbmQuaW50KDEsIDkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICghKHJhbmRvbUtleSBpbiBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG9bcmFuZG9tS2V5XSA9IHRoaXMuZ2VuZXJhdGUocHJvcFtrZXldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByYW5kb21LZXkgPSByayArIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9LFxuICAgIGFycmF5OiBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgaXRlbXMgPSBzY2hlbWEuaXRlbXMgfHwge307XG4gICAgICB2YXIgbWluTGVuZ3RoID0gc2NoZW1hLm1pbkxlbmd0aCAhPSBudWxsID8gc2NoZW1hLm1pbkxlbmd0aCA6IDA7XG4gICAgICB2YXIgbWF4TGVuZ3RoID0gc2NoZW1hLm1heExlbmd0aCAhPSBudWxsID8gc2NoZW1hLm1heExlbmd0aCA6IDE2O1xuICAgICAgdmFyIHR5cGU7XG4gICAgICB2YXIgY2FuZGlkYXRlO1xuICAgICAgdmFyIHNpemU7XG4gICAgICB2YXIgaTtcblxuICAgICAgaWYgKF90eXBlSXMuYXJyYXkoaXRlbXMpKSB7XG4gICAgICAgIHNpemUgPSBpdGVtcy5sZW5ndGg7XG4gICAgICAgIGlmIChzY2hlbWEuZXhhY3RMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICAgIHNpemUgPSBzY2hlbWEuZXhhY3RMZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA8IG1pbkxlbmd0aCkge1xuICAgICAgICAgIHNpemUgPSBtaW5MZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA+IG1heExlbmd0aCkge1xuICAgICAgICAgIHNpemUgPSBtYXhMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY2FuZGlkYXRlID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgICB0eXBlID0gbnVsbDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgIHR5cGUgPSBpdGVtc1tpXS50eXBlIHx8ICdhbnknO1xuICAgICAgICAgIGlmIChfdHlwZUlzLmFycmF5KHR5cGUpKSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZVtfcmFuZC5pbnQoMCwgdHlwZS5sZW5ndGggLSAxKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbmRpZGF0ZVtpXSA9IHNlbGZbdHlwZV0oaXRlbXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gc2NoZW1hLmV4YWN0TGVuZ3RoICE9IG51bGwgPyBzY2hlbWEuZXhhY3RMZW5ndGggOiBfcmFuZC5pbnQobWluTGVuZ3RoLCBtYXhMZW5ndGgpO1xuICAgICAgICBjYW5kaWRhdGUgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgICAgIHR5cGUgPSBpdGVtcy50eXBlIHx8ICdhbnknO1xuICAgICAgICBpZiAoX3R5cGVJcy5hcnJheSh0eXBlKSkge1xuICAgICAgICAgIHR5cGUgPSB0eXBlW19yYW5kLmludCgwLCB0eXBlLmxlbmd0aCAtIDEpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgY2FuZGlkYXRlW2ldID0gc2VsZlt0eXBlXShpdGVtcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgfSxcbiAgICBhbnk6IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyhfdHlwZUdlbmVyYXRvcik7XG4gICAgICB2YXIgaSA9IGZpZWxkc1tfcmFuZC5pbnQoMCwgZmllbGRzLmxlbmd0aCAtIDIpXTtcbiAgICAgIHJldHVybiB0aGlzW2ldKHNjaGVtYSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENhbmRpZGF0ZUdlbmVyYXRvciBDbGFzcyAoU2luZ2xldG9uKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiBDYW5kaWRhdGVHZW5lcmF0b3IoKSB7XG4gICAgLy8gTWF5YmUgZXh0ZW5kcyBJbnNwZWN0aW9uIGNsYXNzIHRvbyA/XG4gIH1cblxuICBfZXh0ZW5kKENhbmRpZGF0ZUdlbmVyYXRvci5wcm90b3R5cGUsIF90eXBlR2VuZXJhdG9yKTtcblxuICB2YXIgX2luc3RhbmNlID0gbnVsbDtcbiAgQ2FuZGlkYXRlR2VuZXJhdG9yLmluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghKF9pbnN0YW5jZSBpbnN0YW5jZW9mIENhbmRpZGF0ZUdlbmVyYXRvcikpIHtcbiAgICAgIF9pbnN0YW5jZSA9IG5ldyBDYW5kaWRhdGVHZW5lcmF0b3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9pbnN0YW5jZTtcbiAgfTtcblxuICBDYW5kaWRhdGVHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgIHZhciB0eXBlID0gc2NoZW1hLnR5cGUgfHwgJ2FueSc7XG4gICAgaWYgKF90eXBlSXMuYXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSB0eXBlW19yYW5kLmludCgwLCB0eXBlLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbdHlwZV0oc2NoZW1hKTtcbiAgfTtcblxuICAvLyBFeHBvcnRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgU2NoZW1hSW5zcGVjdG9yID0ge307XG5cbiAgLy8gaWYgc2VydmVyLXNpZGUgKG5vZGUuanMpIGVsc2UgY2xpZW50LXNpZGVcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFJbnNwZWN0b3I7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LlNjaGVtYUluc3BlY3RvciA9IFNjaGVtYUluc3BlY3RvcjtcbiAgfVxuXG4gIFNjaGVtYUluc3BlY3Rvci5uZXdTYW5pdGl6YXRpb24gPSBmdW5jdGlvbiAoc2NoZW1hLCBjdXN0b20pIHtcbiAgICByZXR1cm4gbmV3IFNhbml0aXphdGlvbihzY2hlbWEsIGN1c3RvbSk7XG4gIH07XG5cbiAgU2NoZW1hSW5zcGVjdG9yLm5ld1ZhbGlkYXRpb24gPSBmdW5jdGlvbiAoc2NoZW1hLCBjdXN0b20pIHtcbiAgICByZXR1cm4gbmV3IFZhbGlkYXRpb24oc2NoZW1hLCBjdXN0b20pO1xuICB9O1xuXG4gIFNjaGVtYUluc3BlY3Rvci5WYWxpZGF0aW9uID0gVmFsaWRhdGlvbjtcbiAgU2NoZW1hSW5zcGVjdG9yLlNhbml0aXphdGlvbiA9IFNhbml0aXphdGlvbjtcblxuICBTY2hlbWFJbnNwZWN0b3Iuc2FuaXRpemUgPSBmdW5jdGlvbiAoc2NoZW1hLCBwb3N0LCBjdXN0b20sIGNhbGxiYWNrKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIGN1c3RvbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBjdXN0b207XG4gICAgICBjdXN0b20gPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNhbml0aXphdGlvbihzY2hlbWEsIGN1c3RvbSkuc2FuaXRpemUocG9zdCwgY2FsbGJhY2spO1xuICB9O1xuXG4gIFNjaGVtYUluc3BlY3Rvci52YWxpZGF0ZSA9IGZ1bmN0aW9uIChzY2hlbWEsIGNhbmRpZGF0ZSwgY3VzdG9tLCBjYWxsYmFjaykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBjdXN0b20gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gY3VzdG9tO1xuICAgICAgY3VzdG9tID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uKHNjaGVtYSwgY3VzdG9tKS52YWxpZGF0ZShjYW5kaWRhdGUsIGNhbGxiYWNrKTtcbiAgfTtcblxuICBTY2hlbWFJbnNwZWN0b3IuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoc2NoZW1hLCBuKSB7XG4gICAgaWYgKHR5cGVvZiBuID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHIgPSBuZXcgQXJyYXkobik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICByW2ldID0gQ2FuZGlkYXRlR2VuZXJhdG9yLmluc3RhbmNlKCkuZ2VuZXJhdGUoc2NoZW1hKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICByZXR1cm4gQ2FuZGlkYXRlR2VuZXJhdG9yLmluc3RhbmNlKCkuZ2VuZXJhdGUoc2NoZW1hKTtcbiAgfTtcbn0pKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/schema-inspector/lib/schema-inspector.js\n");

/***/ })

};
;